{"version":3,"file":"app-build/functionalMonads.js","sources":["app/functionalMonads.js","@traceur/generated/TemplateParser/10","@traceur/generated/TemplateParser/8","@traceur/generated/TemplateParser/6","@traceur/generated/TemplateParser/7","@traceur/generated/TemplateParser/9","@traceur/generated/TemplateParser/0","@traceur/generated/TemplateParser/5","@traceur/generated/TemplateParser/2"],"names":[],"mappings":"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","sourceRoot":"app-build/","sourcesContent":["\n\nimport {m as mImported} from \"./functionalM/baseLib\";\n\nimport {} from \"./functionalM/baseFunctionalGens\";\nimport {} from \"./functionalM/genexporters\";\nimport {} from \"./functionalM/musicalGens\";\n\nvar assert = require(\"assert\");\n\nexport var m = mImported;\n\nvar _ = require(\"lodash\");\n\nconsole.log(\"mprototype\",m.prototype);\n\nvar mTest = m({pitch:10}).loop();\nconsole.log(\"------\",mTest);\nconsole.log(mTest.take(20).toArray().length);\nconsole.log(mTest.take(2).toArray());\nconsole.log(mTest.take(5).toArray());\nassert.equal(mTest.take(1).toArray()[0].pitch,10);\nassert.equal(mTest.take(20).toArray().length,20);\n\n\nvar mEvtTest = m().evt({pitch:10, velocity:[0.7,0.8]});\n\nconsole.log(mEvtTest.take(10).toArray());\n\n\nvar test3 = m().count();\n\nvar countRes = test3.skip(10).take(10).simpleMap(n => n/4).toArray();\nconsole.log(\"countRes\",countRes);\n\nassert.equal(countRes[countRes.length-1],4.75);\n\nvar eventCount = m().evt({pitch:60, velocity: [20,30]}).eventCount().take(20);\nconsole.log(\"evtCountToArray\",eventCount.toArray());\n\nassert.equal(_.last(eventCount.toArray()).count,19);\n\nassert.equal(_.last(eventCount.toArray()).count,19);\n\nassert.equal(_.last(eventCount\n.simpleMap(e => e.set(\"pitch\",e.pitch+10))\n.simpleMap(e => e.set({duration:0.2,pitch: e.pitch+10})).toArray()).pitch,80);\n\nassert.equal(eventCount.prop(\"color\",\"turquoise\").skip(3).takeWhile(e => e.count<5).toArray()[0].count,3);\n\nvar test4=m().evt({pitch:30}).duration(20);\n\nconsole.log(test4.take(10).toArray());\n\nconsole.log(\"---tests---\");\n\nvar testMap = m().evt({pitch: 60, duration: 0.3, velocity: 1}).metro(4)\n// .map(n => [n.set(\"duration\", 0.2),n.set(\"time\", n.time + 2)])\n.automate(\"param1\", (n) => {\n  console.log(\"automationMap\".red.bold,n);\n  return 0.5;\n})\n.automate(\"param2\", (n) => {\n  // console.log(\"automationMap\".red.bold,n);\n  return 0.2;\n})\n.take(10)\n// .lazyResolve()\n// .toPlayable()\n// .toPlayable();\n\n\n// var x =testMap.take(10).toArray();\nconsole.log(testMap.take(10).toArray());\n// console.log(\"\"+x[0][\"$lazy\"]);\n\n// throw \"bye\";\n\n\n// throw \"bye\";\n\n// // TODO: add sanity checks and user understandable errors in every method\n//\n// return;\n//\n// import {\n//   wu\n// }\n// from \"./wu\";\n//\n// import {\n//   prettyToString, toStringObject, toStringDetailed, addFuncProp, /*clone, addObjectProp, addObjectProps, */ isIterable, getIterator, fixFloat\n// }\n// from \"./utils\";\n//\n// import {\n//   immutableTom as immutableObj, addObjectProp, addObjectProps\n// } from \"./nodeProxiedImmutable\";\n//\n// var util = require(\"util\");\n//\n// var _ = require(\"lodash\");\n//\n// var memoize = require('memoizee/weak');\n//\n// var SortedMap = require(\"collections/sorted-map\");\n//\n//\n// var loopGeneratorArgs = function(generatorProducer, args) {\n//   var node = args[args.length - 1];\n//\n// }\n//\n// // // TODO: work in progress\n// // TODO: change to one option param\n// var Immutable = require(\"immutable\");\n// var cacheLimit = 500;\n// var cache_disabled = {\n//   disabled: true\n// };\n//\n// var createCache = function() {\n//   // var cache = new WeakMap();\n//   var caches = {};\n//   return function(key, disable) {\n//     if (disable) {\n//       caches[key] = cache_disabled;\n//       return undefined;\n//     }\n//     if (!caches[key])\n//       caches[key] = [];\n//     return caches[key];\n//   }\n// }\n//\n//\n// var createCacheWM = function() {\n//   var caches = new WeakMap();\n//   // var caches = {};\n//   return function(key) {\n//     // console.log(key);\n//     if (!caches.get(key))\n//       caches.set(key, []);\n//     return caches.get(key);\n//   }\n// }\n//\n// var cache = createCache();\n//\n// var mGenerator = function(...args) {\n//   var origGenerator = args.shift();\n//   if (origGenerator.isTom)\n//     origGenerator[wu.iteratorSymbol] = MCache(origGenerator)[wu.iteratorSymbol];\n//   args.unshift(origGenerator);\n//   if (args.length > 1)\n//     origGenerator.displayName = args[1];\n//   return mGeneratorUnCached(...args);\n// };\n//\n// var doCache = function*(node) {\n//   yield * getIterator(node);\n//   return;\n//\n//   var cacheKey = \"\" + node;\n//   // console.log(\"cacheKey\",cacheKey);\n//   // if (!caches[cacheKey]) {\n//   //   // console.log(\"not yet cashed\".bgBlue.white,cacheKey);\n//   //   caches[cacheKey] = [];\n//   // }\n//\n//   var cached = cache(cacheKey);\n//   if (cached === cache_disabled) {\n//     yield * getIterator(node);\n//     return;\n//   }\n//\n//   var count = 0;\n//   var iterator = null;\n//   while (true) {\n//     if (cached.length <= count || count > cacheLimit) {\n//       if (iterator == null) {\n//         node = MSkip(count, node);\n//         if (count > cacheLimit) {\n//           cache(cacheKey, true);\n//           // console.warn(\"cache full\", node);\n//         }\n//         iterator = getIterator(node);\n//       }\n//       var n = iterator.next();\n//       if (n.done)\n//         break;\n//       if (count > cacheLimit) {\n//         yield n.value;\n//         yield * iterator;\n//         return;\n//         //continue;\n//       }\n//       cached.push(n.value);\n//     }\n//     yield cached[count++];\n//   }\n//\n// }\n//\n// ;\n//\n// var MCache = function(node) {\n//   //return node;\n//\n//   var gen = mGeneratorUnCached(doCache, \"cache\");\n//   return gen(node);\n// }\n//\n//\n// var stackTrace = require('stack-trace');\n//\n// var path = process.cwd();\n//\n//\n// var mGeneratorUnCached = function(generator, name, curryArgCount = 0, toStringOverride = null) {\n//\n//   var getIterable = function(...args) {\n//     // var trace = stackTrace.get();\n//     // console.log(path);\n//     // console.log(trace.map(t => t.toString().replace(path,\"\")).filter(t => t.indexOf(\"evalmachine\")>=0));\n//\n//     var res = Object.create(null);\n//     res.isTom = true;\n//     res.name = name;\n//\n//     res[wu.iteratorSymbol] = () =>  generator(...args); //loopGeneratorArgs(generatorProducer, args);\n//     if (toStringOverride)\n//       res.toString = () => toStringOverride;\n//     else\n//       prettyToString(name, args, res);\n//\n//\n//\n//     return res;\n//   };\n//   getIterable.producerName = name;\n//   getIterable.displayName = name;\n//   //console.log(\"constructed node\",generatorProducer,name);\n//   return curryArgCount > 0 ? wu.curryable(getIterable, curryArgCount) : getIterable;\n// }\n//\n//\n//\n//\n// var MData = mGenerator(function* mData(data) {\n//\n//\n//   // console.log(\"wu\",wu);\n//   //  console.log(\"data\", typeof data, util.isArray(data), isIterable([1,2,3]));\n//   // console.log(\"blaaa\", [1,2,3][@@iterator]);\n//   // console.log(\"iterable\",util.isArray(data), [1,2,3][wu.iteratorSymbol],data[wu.iteratorSymbol]);\n//   if (isIterable(data)) {\n//     for (var d of data) {\n//       // console.log(\"data:\",d);\n//       yield * getIterator(MData(d));\n//     }\n//   } else {\n//     var dataObj;\n//     if (data instanceof Object) {\n//       dataObj = immutableObj(data);\n//\n//\n//       if (isIterable(data))\n//         throw new Error(\"data shouldn't be iterable\");\n//\n//\n//       //   //   //   //   //   // Object.defineProperty(dataObj,\"toString\", {enumerable:false,value:() => toStringDetailed(data)});\n//\n//\n//     } else {\n//       dataObj = immutableObj({\n//         type: \"value\",\n//         valueOf: () => data\n//       });\n//       console.log(\"created dataObj from value\", dataObj);\n//     }\n//     yield dataObj;\n//   }\n// }, \"data\");\n//\n//\n// // for (var e of MData([{\n// //     pitch: 12,\n// //     velocity: 0.5\n// //   }, {\n// //     bla: 2\n// //   }]))\n// //   console.log(\"datatest\", e);\n//\n//\n// // TODO: remove this data generator nonsense? if it's not used later yes!\n// var MLoopData = mGenerator(function* loopData(dataNode) {\n//   for (var data of dataNode) {\n//     var keys = Object.keys(data);\n//\n//     if (keys.length == 0) {\n//       yield * getIterator(MLoop(dataNode));\n//       return;\n//     }\n//\n//     for (var props of MZip(..._.values(data))) {\n//       //console.log(zippedProps);\n//\n//       var resData = props.reduce(function(prev, val, i) {\n//         // console.log(\"reduceLoopData\",prev,keys[i]+\":\"+val,i);\n//         return prev.set(keys[i], val);\n//       }, immutableObj());\n//       //resData._data = data;\n//       yield immutableObj(resData);\n//     }\n//   }\n// }, \"loopData\");\n//\n// function* ftesttest() {\n// console.log(\"hey\",this);\n// }\n// ftesttest.constructor.bind({hey:2});\n//\n// console.log(ftesttest.name,ftesttest().next());\n// throw \"bye\";\n//\n//\n// var MMergeZipped = mGenerator(function* zipMerge(node) {\n//   for (var n of node)\n//     yield addObjectProps(n[0], n[1]);\n// }, \"mergeZippedObjects\");\n//\n// var MMerge = mGenerator(function* simpleMerge(node1, node2) {\n//   var iterators = [node1, node2].map((node) => getIterator(node));\n//   while (true) {\n//     var next = iterators.map((i) => i.next().value);\n//     if (next[0] == undefined || next[1] == undefined)\n//       return;\n//     // console.log(\"addobprops\",next[0], next[1]);\n//     yield addObjectProps(next[0], next[1]);\n//   }\n// }, \"mergeObjects\");\n//\n// var MSet = mGenerator(function* set(data, node) {\n//   yield * getIterator(MMerge(node, MLoopData(MData(data))));\n// }, \"set\");\n//\n//\n// // TODO: if we leave out the shallow check we automatically have a flatmap (Maybe??)\n// var MEvent = mGenerator(function* evt(data) {\n//   // here if data is iterable we are not looping individual properties\n//   if (isIterable(data)) {\n//     for (var e of MLoop(data))\n//       yield * getIterator(MData(e));\n//   } else\n//     yield * getIterator(MLoopData(MData(data)));\n// }, \"evt\");\n//\n//\n// var MProperty = mGenerator(function* prop(name, tomValue, children) {\n//   yield * getIterator(MSet({\n//     [name]: tomValue\n//   }, children));\n// }, \"prop\", 3);\n//\n//\n// var MWithNext = mGenerator(function* withNext(node) {\n//   var me = null;\n//   for (var n of node) {\n//     if (me == null) {\n//       me = n;\n//       continue;\n//     }\n//     // console.log({me:me,next:n, time:me.time });\n//     yield addObjectProps(me, {\n//       next: n\n//     });\n//     me = n;\n//   }\n// }, \"withNext\")\n//\n// var MGroupTime = mGenerator(function* groupByTime(node) {\n//   var currentTime = -1;\n//   var grouped = [];\n//   //console.log(\"\"+node);\n//   for (var n of node) {\n//     if (!n.hasOwnProperty(\"time\")) {\n//       console.error(\"groupByTime called but no time property\".red);\n//       return;\n//     }\n//     if (n.time > currentTime) {\n//\n//       if (grouped.length > 0) {\n//         yield immutableObj({\n//           events: grouped,\n//           time: currentTime\n//         });\n//         grouped = [];\n//       }\n//       currentTime = fixFloat(n.time);\n//     }\n//     grouped.push(n);\n//   }\n// }, \"groupByTime\");\n//\n// var MDuplicateRemover = mGenerator(function*(node) {\n//\n//\n//   for (var timeGrouped of MGroupTime(node)) {\n//\n//     //console.log(_.groupBy(timeGrouped, \"pitch\"));\n//     for (var n of _.values(_.groupBy(timeGrouped.events, \"pitch\")))\n//       yield n[n.length - 1]; // last one... could be first too\n//\n//   }\n//\n// }, \"removeDuplicateNotes\");\n//\n//\n//\n//\n//\n// var MNoteAutomate = mGenerator(function* noteAutomate(node) {\n//   // console.log(MToArray(MTake(2,node)));\n//\n//   var notes = MFilter((n) => n.hasOwnProperty(\"pitch\") && n.hasOwnProperty(\"velocity\") && n.hasOwnProperty(\"time\") && n.duration > 0, node);\n//   // console.log(MToArray(MTake(2,notes)));\n//\n//   // console.log(\"notes\", m.data(notes).take(5).toArray());\n//   yield * getIterator(MMapOp((n) => {\n//       // var automationHolder = n.hasOwnProperty(\"children\") ? n.children : Object.create(null);\n//       var automation = m.data([{\n//         type: \"noteOn\",\n//         velocity: n.velocity,\n//         pitch: n.pitch,\n//         time: 0,\n//         evt: n\n//       }, {\n//         type: \"noteOff\",\n//         pitch: n.pitch,\n//         time: n.duration,\n//         evt: n\n//       }]);\n//       automation.automation = true;\n//       // console.log(\"returing automation\",{[\"automation_note\"]: automation});\n//       return {\n//         [\"automation_note\"]: automation\n//       };\n//     },\n//     MDuplicateRemover(notes)));\n// }, \"notePlay\");\n//\n//\n// //TODO: figure out how to deal with automations of notes that overlap in duration. at the moment automations are overlapping\n// var MAutomate = mGenerator(function* automate(paramName, valGenerator, node) {\n//   yield * getIterator(MMapOp((n) => {\n//     // var automationHolder = n.hasOwnProperty(\"children\") ? n.children : Object.create(null);\n//     var automation = m.data({\n//         type: \"automation\",\n//         evt: n,\n//         name: paramName,\n//         duration: n.duration\n//       }).loop()\n//       .metro(1 / 8)\n//       //  .log(\"automation\")\n//       .takeWhile((a) => a.time < a.evt.duration)\n//       .set({\n//         automationVal: valGenerator\n//       });\n//\n//     automation.automation = true;\n//     return {\n//       [paramName]: automation\n//     };\n//   }, node));\n// }, \"automate\");\n//\n//\n//\n// var MProcessAutomations = mGenerator(function* processAutomations(node) {\n//   // if (MToArray(MNoteAutomate(MTake(100,node))).length ==0)\n//   //   throw \"no notes to automate\";\n//\n//   yield * getIterator(MCache(MFlattenAndSchedule(MSimpleMap((n) => {\n//     var merged = m.data([]);\n//     for (var automation of _.filter(_.values(n), (nVal) => Object(nVal).automation === true)) {\n//       // console.log(\"processing automation\",automation.toArray());\n//       // throw \"hey\";\n//       merged = merged.merge(automation);\n//     }\n//     // console.log(\"mapping\",n);\n//     // console.log(\"returning for flatten and schedule\", {time:n.time, events: merged.delay(n.time).toArray()});\n//     return immutableObj({\n//       time: n.time,\n//       events: merged.delay(n.time)\n//     });\n//   }, MNoteAutomate(node)))));\n//\n// }, \"processAutomations\");\n//\n//\n//\n// // var MAutomatePlay = mGenerator(function*(propName,node) {\n// //   for (var v of node) {\n// //     var play = mGenerator(function* () {\n// //       //console.log(\"called playMethod of automateplay\");\n// //\n// //\n// //       return baconTime\n// //         .skipWhile((t) => t.time < v.time)\n// //         .takeWhile((t) => v.duration ? t.time < v.time + v.duration : true)\n// //\n// //         .map((t) => {\n// //           //console.log(\"returning automateplay function\",v[name]);\n// //           return function(instrument) {\n// //             //console.log(\"calling instrument\", );\n// //             instrument.param(name, v[name](t.time,v), t.time + t.offset)\n// //           };\n// //         });\n// //     },\"automationPlayer\");\n// //     var playerObj = _.extend({},v.instrumentPlayers, {[name]: playMethod})\n// //     yield addObjectProp(v, \"instrumentPlayers\", playerObj);\n// //   }\n// // },\"automatePlay\",2);\n//\n//\n// var MSetValue = mGenerator(function* setValue(value, child) {\n//   //  console.log(\"MSetValue\", value, child);\n//   yield * MProperty(\"value\", value, child);\n// }, \"setValue\", 2);\n//\n//\n//\n// var MZip = mGenerator(function* zip(...nodes) {\n//\n//\n//   var loopedIterators = nodes.map((node) => {\n//     console.log(node.length,MLoop(node),MLoop(node).length)\n//     return getIterator(MLoop(node))\n//   });\n//   while (true) {\n//     var next = loopedIterators.map((i) => i.next().value);\n//     yield next;\n//   }\n// }, \"zip\");\n//\n//\n//\n// var MLoop = mGenerator(function*(node) {\n//   if (isIterable(node)) {\n//     if (node.length>0)\n//       node = Array.from(node);\n//     while(true)\n//       yield* getIterator(node);\n//   }\n//   else\n//     while(true)\n//       yield node;\n// }, \"loop\");\n//\n//\n//\n//\n//\n//\n//\n// var simpleMap = mGenerator(function* simpleMap(mapFunc, node) {\n//   for (var n of node) {\n//     yield mapFunc(n);\n//   }\n// }, \"simpleMap\");\n//\n//\n//\n// var MCombine = mGenerator(function* combine(combineNode, node) {\n//   var combineFunc = (me, previousOther, nextOther) => addObjectProps(me, {\n//     other: {\n//       previous: previousOther,\n//       next: nextOther\n//     }\n//   });\n//   var meMapped = simpleMap((n) => {\n//     return {\n//       time: n.time,\n//       me: n\n//     }\n//   }, node);\n//   var otherMapped = simpleMap((n) => {\n//     return {\n//       time: n.time,\n//       other: n\n//     }\n//   }, combineNode);\n//   var merged = MTimeOrderedMerge(meMapped, otherMapped);\n//   // for (var test of merged)\n//   //   console.log(\"mergedSeq\", test);\n//   var previousOther = null;\n//   var nextOther = null;\n//   var meWaitingForNextOther = [];\n//   for (var m of merged) {\n//     // console.log(\"combining\",m);\n//     if (m.hasOwnProperty(\"me\"))\n//       meWaitingForNextOther.push(m.me);\n//     if (m.hasOwnProperty(\"other\") && meWaitingForNextOther.length > 0) {\n//       previousOther = nextOther;\n//       nextOther = m.other;\n//       for (var me of meWaitingForNextOther) {\n//         yield combineFunc(me, previousOther, nextOther);\n//       }\n//       meWaitingForNextOther = [];\n//     }\n//   }\n//   for (var me of meWaitingForNextOther) {\n//     yield combineFunc(me, previousOther, nextOther);;\n//   }\n// }, \"combine\");\n//\n// var MCombineMap = mGenerator(function*(combineFunc, combineNode, node) {\n//   // here we could add time diffs to parameters of combineFunc\n//   yield * getIterator(MMapOp((combined) => combineFunc(combined, combined.other), MCombine(combineNode, node)));\n// }, \"combineMap\", 3);\n//\n//\n// // var MCombine2 = mGenerator(function*(combineFunc, combineNode,node) {\n// //   var cIterator = getIterator(combineNode);\n// //   var cNext = [];\n// //   cNext.push(cIterator.next().value);\n// //   cNext.push(cIterator.next().value);\n// //   for (var n of node) {\n// //     // make it do a zip in case of no time value present ( later)\n// //     //if (cNext[0].time == undefined || cNext[1].time == undefined || n.time == undefined)\n// //     while (n.time > cNext[1].time) {\n// //       cNext.shift();\n// //       cNext.push(cIterator.next().value);\n// //     }\n// //\n// //     if (n.time <= cNext[1].time) {\n// //       if (n.time < cNext[0].time)\n// //         combineFunc({prev: undefined, next: cNext[0]});\n// //       else\n// //         if (n.time > cNext[0].time && n.time <= cNext[1].time)\n// //           combineFunc({prev:cNext[0], next: cNext[1]});\n// //     }\n// //\n// //   }\n// // },\"combine\",3);\n//\n//\n// var MCompose = mGenerator(function* compose(...nodes) {\n//   for (var node of nodes) {\n//     yield * getIterator(node);\n//   }\n// }, \"compose\");\n//\n//\n//\n// var MLoopFixedLength = mGenerator(function* loopLength(loopLength, node) {\n//   var time = 0;\n//   while (true) {\n//     for (var n of node) {\n//       //  console.log(\"looplengtime\",time);\n//       yield addObjectProp(n, \"time\", time + n.time);\n//     }\n//     time += loopLength;\n//   }\n// }, \"loopLength\", 2);\n//\n// var convertToObject = (externalVal) => Object(externalVal);\n//\n//\n// var MSimpleMap = mGenerator(function* simpleMap(mapFunc, node) {\n//   for (var e of node) {\n//     // console.log(\"mapping\",e);\n//     yield mapFunc(e);\n//     // console.log(\"after mapping\",e);\n//     //throw \"hey\";\n//   }\n// }, \"simpleMap\");\n//\n//\n// var MFlattenAndSchedule = mGenerator(function* flattenAndSchedule(node) {\n//   var scheduled = new SortedMap();\n//   var passedInStartTime = null;\n//   for (var n of node) {\n//     //console.log(n);\n//     if (n.hasOwnProperty(\"time\")) {\n//       var scheduledNow = _.take(scheduled.entries(), (s) => s[0] < n.time);\n//       // if (passedInStartTime != null)\n//       //   scheduledNow = _.filter(scheduledNow, s[0] >= startTime);\n//       //console.log(scheduledNow);\n//       for (var scheduledEvents of scheduledNow) {\n//\n//         for (var scheduledEvent of scheduledEvents[1]) {\n//           passedInStartTime =\n//             yield scheduledEvent;\n//         }\n//         // if (passedInStartTime)\n//         //   for (let [key,evt] of scheduledNow)\n//         //     if (key < passedInStartTime) {\n//         //       scheduled.delete(key);\n//         //       console.log(\"deleting \",key,\"passedInTime\",passedInStartTime);\n//         //     }\n//         //     else\n//         //       break;\n//         scheduled.delete(scheduledEvents[0]);\n//       }\n//     } else\n//       console.error(\"Flatten and Schedule should work on events with time set\");\n//     // if (!isIterable(n))\n//     //   n=[n];\n//     for (var nFlat of n.events) {\n//       //    console.log(nFlat);\n//       if (nFlat.hasOwnProperty(\"time\")) {\n//         // if (passedInStartTime && nFlat.time < passedInStartTime)\n//         //   continue;\n//         if (nFlat.time <= n.time)\n//           yield nFlat;\n//         else {\n//           if (!scheduled.has(nFlat.time)) {\n//             // console.log(\"nflat\",nFlat, nFlat.time);\n//             scheduled.set(nFlat.time, []);\n//           }\n//           scheduled.get(nFlat.time).push(nFlat);\n//         }\n//       } else\n//         console.error(\"Flatten and Schedule should work on events with time set\");\n//     }\n//   }\n//\n//   yield * getIterator(scheduled.values());\n// }, \"flattenAndSchedule\");\n//\n//\n// var MFlattenShallow = mGenerator(function*(node) {\n//   for (var n of node) {\n//     if (isIterable(n))\n//       yield * getIterator(n);\n//     else\n//       yield n;\n//   }\n// }, \"flattenShallow\");\n//\n// var MMapOp = mGenerator(function*(mapFunc, node) {\n//   var mapped = MSimpleMap(mapFunc, node);\n//\n//   var timed = false;\n//\n//   var merged = MSimpleMap((e) => {\n//     var mappedRes = MData(e[1]);\n//     var orig = e[0];\n//     //console.log(\"merging\",orig,\"mappedRes\", mappedRes);\n//     var res = {\n//       events: MSimpleMap((m) => addObjectProps(orig, m), mappedRes)\n//     };\n//\n//     if (orig.hasOwnProperty(\"time\")) {\n//       res.time = orig.time;\n//       timed = true;\n//     }\n//\n//     return res;\n//   }, MZip(node, mapped));\n//\n//\n//   // for (var z of MTake(5,merged))\n//   //   console.log(\"merged\",z);\n//   if (timed)\n//     yield * getIterator(MFlattenAndSchedule(merged));\n//   else\n//     yield * getIterator(MFlattenShallow(MSimpleMap((e) => e.events, merged)));\n// });\n//\n//\n// // somehow like sequencer\n// var MCombineLast = mGenerator(function*(combineFunc, combineNode, node) {\n//   var meIterator = getIterator(node);\n//   //var meNext = null;\n//   var last = meIterator.next().value;\n//   for (var c of combineNode) {\n//     var next = meIterator.next();\n//     if (next.time < c.time) {\n//       last = next;\n//       continue;\n//     }\n//     yield combineFunc(last, next, combineNode);\n//\n//     last = next;\n//   }\n// });\n//\n//\n// var MFlatten = mGenerator(function*(node) {\n//   for (var e of node)\n//     if (isIterable(e))\n//       yield * getIterator(MFlatten(e))\n//     else\n//       yield e;\n// }, \"flatten\");\n//\n//\n// var MSubSequence = mGenerator(function*(subSequence, node) {\n//   // change yield* to iterating through subSequence\n//   yield * node;\n//   yield * subSequence;\n// }, \"subSequence\");\n//\n// var MPluck = mGenerator(function*(propertyName, node) {\n//   yield * getIterator(MMapOp(e => e[propertyName], node))\n// }, \"pluck\", 2);\n//\n// var MMapWithMemory = mGenerator(function*(initial, mapFunc, node) {\n//   var current = initial;\n//   yield * getIterator(MSet(convertToObject(current), MData(current)));\n//   for (var e of node) {\n//     current = mapFunc(current, e.value);\n//     //  console.log(\"current\",current);\n//     yield * getIterator(MSet(convertToObject(current), MData(e)));\n//   }\n// }, \"memoryMap\", 3);\n//\n//\n// var MFilter = mGenerator(function*(filterFunc, node) {\n//   for (var e of node) {\n//     if (filterFunc(e))\n//       yield e;\n//   }\n// }, \"filter\", 2);\n//\n//\n//\n// var MTakeWhile = mGenerator(function*(filterFunc, node) {\n//   for (var e of node) {\n//     if (!filterFunc(e))\n//       break;\n//     yield e;\n//   }\n// }, \"takeWhile\", 2);\n//\n// var MSkipWhile = mGenerator(function*(skipFunc, node) {\n//   var skipNo = 0;\n//   for (var e of node) {\n//     if (skipFunc(e)) {\n//       continue;\n//     }\n//     yield e;\n//   }\n// }, \"skipWhile\", 2);\n//\n//\n// var MTake = mGenerator(function*(n, node) {\n//   var count = n;\n//   // console.log(\"mtake\",node,n);\n//   for (var e of node) {\n//     yield e;\n//     if (--count <= 0)\n//       break;\n//   }\n// }, \"take\", 2);\n//\n// var MTakeTime = mGenerator(function*(time, node) {\n//   var timeTaken = 0;\n//   for (var e of node) {\n//     yield e;\n//     timeTaken += e.event.duration;\n//     if (timeTaken >= time)\n//       break;\n//   }\n// }, \"takeTime\", 2);\n//\n// var MRepeat = mGenerator(function*(n, node) {\n//   yield * getIterator(MTake(n, MLoop(node)));\n// }, \"repeat\", 2);\n//\n// var MMapTime = mGenerator(function*(mapFunc, node) {\n//   for (var e of node) {\n//     yield e.set(\"time\", mapFunc(e.time));\n//   }\n// }, \"mapTime\", 2);\n//\n// var MTimeShift = mGenerator((amount, node) => MMapTime((time) => time + amount, node), \"timeShift\", 2);\n//\n// var MReduce = mGenerator(function*(reduceFunc, startValue, node) {\n//   var current = startValue;\n//   for (var e of node) {\n//     current = reduceFunc(current, e);\n//   }\n//   yield current;\n// }, \"reduce\", 3);\n//\n//\n// var MDurationSum = mGenerator(MReduce((sum, timedEvent) => sum + timedEvent.duration, 0), \"durationSum\");\n//\n//\n// var MSkip = mGenerator(function*(n, node) {\n//   var count = n;\n//   for (var e of node) {\n//     if (count > 0)\n//       count--;\n//     else\n//       yield e;\n//   }\n// }, \"skip\", 2);\n//\n// var MBranch = mGenerator(function*(condition, branchNode, elseNode, node) {\n//   for (var e of node) {\n//     //console.log(\"branching\", condition, e);\n//     var branchTo = (condition(e) ? branchNode : elseNode);\n//\n//     //console.log(e,branchTo.set);\n//     yield * getIterator(branchTo.takeWhile((n) => n.time < e.duration).set({\n//       time: (n) => n.time + e.time\n//     }));\n//     //yield* getIterator(branchTo\n//     //  .takeWhile((n) => n.time < e.duration)\n//     //  .set((n) => {time: n.time+e.time})\n//     //);\n//   }\n// }, \"branch\", 4);\n//\n//\n//\n// var MCount = mGenerator(function*(start = 0, stepSize = 1) {\n//   var c = start;\n//   while (true) {\n//     yield c;\n//     c += stepSize;\n//   }\n// }, \"count\");\n//\n// var MSequenceEndMarker = mGenerator(function*() {\n//   yield * getIterator(MEvent({\n//     type: \"endMarker\"\n//   }))\n// }, \"endMarker\");\n//\n// var MPitch = MProperty(\"pitch\");\n// var MVelocity = MProperty(\"velocity\");\n// var MTime = MProperty(\"time\");\n// var MDuration = MProperty(\"duration\");\n// var MEventCount = MProperty(\"count\", MCount(0, 1));\n//\n// var MDelay = mGenerator(function*(amount, node) {\n//   //console.log(\"delaying\", node.toArray());\n//   if (!isIterable(amount))\n//     amount = [amount];\n//\n//   for (var a of amount)\n//     yield * getIterator(MProperty(\"time\", (n) => n.time + a, node));\n// }, \"delay\");\n//\n//\n// // maybe possible to modify event properties to have iterables with time somehow connecting to time of external events\n// var MExternalProperty = mGenerator(function*(propName, baconProp, initialVal, node) {\n//   var propVal = initialVal;\n//   // set up bacon listener\n//   baconProp.onValue(function(v) {\n//     console.log('new param val', propName, v);\n//     propVal = v;\n//   });\n//\n//   var res = MProperty(propName, () => propVal, node);\n//\n//   yield * getIterator(res);\n// }, \"externalProperty\", 3, \"externalProp\");\n//\n//\n// var MMetronome = mGenerator(function*(tickDuration, node) {\n//   yield * getIterator(MTime(MCount(0, tickDuration), MCompose(node, MSequenceEndMarker())));\n// }, \"metro\");\n//\n// var MTimeFromDurations = mGenerator(function*(node) {\n//   var durationSumIterator = MMapWithMemory(0, (current, x) => x + current, MPluck(\"duration\", node));\n//   yield * getIterator(MTime(durationSumIterator, MCompose(node, MSequenceEndMarker())));\n// }, \"timeFromDurations\");\n//\n//\n// var MDurationsFromTime = mGenerator(function*(node) {\n//   var i = getIterator(node);\n//   var previous = undefined;\n//   while (true) {\n//     var next = i.next().value;\n//     if (next === undefined)\n//       return;\n//     if (previous != undefined && previous.hasOwnProperty(\"time\") && next.hasOwnProperty(\"time\")) {\n//       yield addObjectProps(previous, {\n//         duration: next.time - previous.time - 0.01\n//       });\n//     }\n//     previous = next;\n//   }\n// });\n//\n// // var MInsertWhen = MDirectOp(\n// //   function* (nodeIterator, insertCondition, insertNode) {\n// //     for (var e of nodeIterator) {\n// //       if (insertCondition(e))\n// //         yield* insertNode;\n// //       yield e;\n// //     }\n// //   }\n// // )\n//\n//\n// // before insert, could make explicit\n// //var MInsertOnce = (insertCondition, insertNode, node) => MCompose(MTakeWhile(e => !insertCondition(e),node), insertNode, MSkipWhile(e => !insertCondition(e),node));\n//\n//\n//\n// var MTimeOrderedMerge = mGenerator(function*(mergeNode, node) {\n//   var nodeIterator = getIterator(node);\n//   var nextNode = nodeIterator.next().value;\n//   for (var mergeEvent of mergeNode) {\n//     while (nextNode != undefined && nextNode.time < mergeEvent.time) {\n//       yield nextNode;\n//       nextNode = nodeIterator.next().value;\n//     }\n//     yield mergeEvent;\n//   }\n//   if (nextNode != undefined)\n//     yield nextNode;\n//   yield * nodeIterator;\n// }, \"merge\");\n//\n//\n//\n// // safe and ordered NoteOnOffSequence generator which doesn't cause StackOverflows. not very functionally elegant;\n// var MNoteOnOffSequence = mGenerator(function*(node) {\n//   var iterator = getIterator(node);\n//   var next = null;\n//   var toInsert = {};\n//   while (next = iterator.next().value) {\n//     var ks = Object.keys(toInsert)\n//     for (var time of ks) {\n//       if (time < next.time) {\n//         yield * toInsert[time];\n//         delete toInsert[time];\n//       }\n//     }\n//     if (next.type == \"note\") {\n//       //console.log(next.set(\"type\", \"noteOn\"));\n//       yield addObjectProp(next, \"type\", \"noteOn\");\n//       //console.log(\"next\",next,next.time);\n//       var noteOffTime = next.time + next.duration - 1;\n//\n//       var noteOff = MEvent({\n//         type: \"noteOff\",\n//         pitch: next.pitch,\n//         time: noteOffTime\n//       });\n//       //console.log(\"inserting noteOff\", noteOff)\n//       toInsert[noteOffTime] = noteOff;\n//     } else {\n//       yield next;\n//     }\n//   }\n// }, \"noteOnOff\");\n//\n// var MSwing = mGenerator(function*(timeGrid, amount, node) {\n//   yield * getIterator(MTime((e) => {\n//     // console.log(\"swing, mapping,\",e);\n//     var diff = (e.time % (timeGrid * 2)) / timeGrid - 1;\n//\n//     var dist = diff * diff;\n//     // console.log(\"swing\", {time: fixFloat(e.time + amount * (1-dist) * timeGrid)});\n//     return fixFloat(e.time + amount * (1 - dist) * timeGrid);\n//   }, node))\n// }, \"swing\", 3);\n//\n// var MQuantize = mGenerator(function*(timeGrid, amount, node) {\n//   yield * getIterator(MTime((e) => {\n//     // console.log(\"swing, mapping,\",e);\n//     var diff = (e.time % (timeGrid * 2)) / timeGrid - 1;\n//\n//\n//     // console.log(\"swing\", {time: fixFloat(e.time + amount * (1-dist) * timeGrid)});\n//     return fixFloat(e.time - amount * diff);\n//   }, node))\n// }, \"quantize\", 3);\n//\n//\n// var MLog = mGenerator(function*(name, node) {\n//   for (var e of node) {\n//     console.log(name, e);\n//     yield e;\n//   }\n// }, \"log\");\n//\n// var MBjorklund = mGenerator(function*(steps, pulses, rotation, node) {\n//   var pattern = bjorklund(steps, pulses);\n//   var counter = rotation;\n//   // console.log(pattern, steps, pulses);\n//   if (pattern.length == 0)\n//     pattern = [1];\n//   for (var n of node) {\n//     if (pattern[counter++ % pattern.length])\n//       yield n;\n//   }\n// }, \"bjorklund\", 4);\n//\n// function bjorklund(steps, pulses) {\n//\n//   steps = Math.round(steps);\n//   pulses = Math.round(pulses);\n//\n//   if (pulses > steps || pulses == 0 || steps == 0) {\n//     return new Array();\n//   }\n//\n//   var pattern = [],\n//     counts = [],\n//     remainders = [],\n//     divisor = steps - pulses;\n//   remainders.push(pulses);\n//   var level = 0;\n//\n//   while (true) {\n//     counts.push(Math.floor(divisor / remainders[level]));\n//     remainders.push(divisor % remainders[level]);\n//     divisor = remainders[level];\n//     level += 1;\n//     if (remainders[level] <= 1) {\n//       break;\n//\n//\n//     }\n//   }\n//\n//   counts.push(divisor);\n//\n//   var r = 0;\n//   var build = function(level) {\n//     r++;\n//     if (level > -1) {\n//       for (var i = 0; i < counts[level]; i++) {\n//         build(level - 1);\n//       }\n//       if (remainders[level] != 0) {\n//         build(level - 2);\n//       }\n//     } else if (level == -1) {\n//       pattern.push(0);\n//     } else if (level == -2) {\n//       pattern.push(1);\n//     }\n//   };\n//\n//   build(level);\n//   return pattern.reverse();\n// }\n//\n//\n// function MToArray(node) {\n//   var res = [];\n//   for (var n of node)\n//     res.push(n.valueOf());\n//   return res;\n// }\n//\n// var Rx = require(\"Rx\");\n//\n// var MToRx = (node) => Rx.Observable.from(node);\n//\n// var wait = require('wait.for-es6');\n//\n// var MfromRx = function*(rxObservable) {\n//   return {\n//     next: function*() {\n//       var nextVal =\n//         yield wait.for(rxObservable.onValue);\n//       return {\n//         value: nextVal,\n//         done: false\n//       };\n//     }\n//   }\n// }\n//\n\n// import {kick} from \"abletonClip\";\nvar kickGrid = 2;\n\nexport var kick = m().evt({\n    pitch: [54, 60, 65],\n    velocity: 0.9,\n    duration: kickGrid - 0.5\n  }).metro(kickGrid)\n  .automate(\"pitchBend\", (n) => {\n  console.log(\"automate called\",n);\n  return Math.sin((n.time + n.target.time) * Math.PI / 1) / 4 + 0.5\n  });\n\n\nexport var tom = m().evt({\n  pitch: 60,\n  velocity: 0.7,\n  duration: 0.1,\n  color: \"yellow\"\n}).metro(0.2).bjorklund(16, 9, 2);\n\n\n// var rxified = tom.take(100).toRx();\n//\n// rxified.subscribe((v) => console.log(\"rx\",v));\n\n// var mified = m.fromRx(rxified);\n\n// console.log(mified.toArray());\n\nvar log=console.log;\n// console.log = () => ({});\n\nexport var hat = m().evt({\n  pitch: [48, 60],\n  velocity: [0.3, 0.5, 0.7, 0.3, 0.6],\n  duration: 0.1\n}).metro(0.25).bjorklund(4, 3, 0).swing(1 / 4, 0.15);\n\nexport var kick_real = m().evt({\n  pitch: 60,\n  velocity: [0.9, 0.7, 0.8],\n  duration: 0.1\n}).metro(1);\n// .automate(\"pitchBend\", n => Math.sin((n.time+n.evt.time)*Math.PI/8)/4+0.5)\n\nvar microtime = require(\"microtime\");\n\n\nvar profilerDataStore = [];\nvar profileSamples = 200;\n\n\nvar startTime = microtime.nowDouble();\n\n// console.log(kick.toPlayable()[wu.iteratorSymbol]);\n\nfor (var n of kick\n  .toPlayable()\n  .take(profileSamples)) {\n  var x = ({\n    time: n.time,\n    pitch: n.pitch,\n    veloctiy: n.velocity,\n    type: n.type\n  });\n  console.log(n);\n}\n\nvar timeTaken = microtime.nowDouble() - startTime;\nlog(\"time:\", timeTaken);\nlog(\"-------------\".bgRed);\nconsole.log(kick.toPlayable().take(50).toArray()[49]);\n// throw \"bye\";\n\nfor (var n of tom\n  .toPlayable()\n  .take(profileSamples)) {\n  var cx = ({\n    time: n.time,\n    pitch: n.pitch,\n    veloctiy: n.velocity\n  });\n}\n\n\n// startTime = microtime.nowDouble();\ntimeTaken = microtime.nowDouble() - startTime;\nlog(\"time:\", timeTaken);\n\nfor (var n of tom\n  .toPlayable()\n  .take(profileSamples)) {\n  var x = ({\n    time: n.time,\n    pitch: n.pitch,\n    veloctiy: n.velocity,\n    type: n.type\n  });\n  x = ({\n    time: n.time,\n    pitch: n.pitch,\n    veloctiy: n.velocity,\n    type: n.type\n  });\n  x = ({\n    time: n.time,\n    pitch: n.pitch,\n    veloctiy: n.velocity,\n    type: n.type\n  });\n}\n\ntimeTaken = microtime.nowDouble() - startTime;\nlog(\"time2:\", timeTaken);\n\n\nfor (var n of tom\n  .toPlayable()\n  .take(profileSamples))\n  var x = ({\n    time: n.time,\n    pitch: n.pitch,\n    veloctiy: n.velocity\n  });\n\ntimeTaken = microtime.nowDouble() - startTime;\nlog(\"time:\", timeTaken);\n\n// throw \"bye\";\n\n\n// console.log = col;\n// throw \"bye\";\n\n\n// throw \"bye\";\n//\n//\n// // var test1 = m.evt({pitch:12}).metro(10).automate(\"param1\",(n) => 0.5).delay(10);\n// // var test2 = m.evt({pitch:3, velocity:0.3}).metro(4);\n// // console.log(test1);\n// // throw \"bye\";\n//\n//\n// // for (var m of test1)\n// //   console.log(\"test1\",m.time, m);\n// // for (var m of test2)\n// //   console.log(\"test2\",m.time, m);\n//\n// // var combined = test2.combineMap((c,other) =>  {\n// //   var nextTime = null;\n// //   var prevTime = null;\n// //   //console.log(\"other\",other);\n// //\n// //   if (c.other.previous)\n// //     prevTime = combine.previous.time;\n// //   if (combine.next)\n// //     nextTime = combine.next.time;\n// //   //console.log(me, combine,\"prevTime:\",prevTime,\"nextTime\",nextTime);\n// //\n// //   return {pitch: nextTime == me.time ? 5: 24}\n// // }, test1);\n//\n// // console.log(test2.combine(test1).take(5));\n// // for (var c of combined.take(5))\n// //   console.log(\"combined\",c);\n//\n// // var test1 =m.evt({pitch:20, velocity:[30,40], duration:0.5}).metro(0.25).duration([0.3,0.7])\n// // .swing(0.25,0.1)\n// // .map((n) => {return {velocity: n.velocity/100}})\n// // .notePlay();\n//\n// // throw \"just terminating\";\n// //\n// // var simpleMelody = m.evt().set({pitch:[62,65,70,75], velocity:[0.8,0.6,0.5], duration:1.5}).metro(2)\n// // // .duration((n) => {\n// // // //  console.log(\"durationmap\",n);\n// // //   return n.duration*200\n// // // })\n// // .duration((n) => {\n// // //  console.log(\"durationmap\",n);\n// //   return n.duration;\n// // })\n// // .swing(1,0.3)\n// // .automate(\"pitchBend\",(n) => 1.5);\n//\n//\n// // console.log(simpleMelody);\n//\n//\n//\n// // throw \"Byebye\";\n// //\n// //\n// // for (var e of simpleMelody.skip(10).toPlayable().take(5)) {\n// //   console.log(\"eventNoteOnOffYeeee\",e);\n// // }\n//\n//\n// // console.log(\"getting combined\");\n// // for (var m of combined) {\n// //\n// //   console.log(\"combined\",m);\n// // }\n// //\n//\n// //var count = MTime(MCount(0,1),MLoop(MEvent({pitch:[12,13,100]})));\n// //for (var c of count)\n// //  console.log(c);\n// //var automator = m.value([40,50]).set({duration:t.bars(1)}).timeFromDurations().automatePlay(\"pitchBend\");\n// //for (var a of automator) {console.log(a);}\n// //return;\n// //\n// //\n// // //console.log(\"iteratorSymbol\",wu.iteratorSymbol);\n// //\n// // var val = MValue(40);\n// // for (var e of val) {\n// //   console.log(\"VAAL\",e);\n// // }\n// // //return;\n// //\n// // var valtest = m.value().loop().setValue([20,30,40,50]).take(5);\n// // console.log(\"VAAAAAL3\",[for (e of valtest) e]);\n// //\n// //\n// // var valToNoteTest3 = m.note({pitch:12, duration:10,time:0})\n// //   .loop()\n// //   .set({pitch:[12,13]})\n// //   .set({velocity:[11,50,60]})\n// //   .set({time: m.count(0,20), bla: (n) => {console.log(\"inSet\",n); return Math.random()}})\n// //   .set({test2: m.value().loop().setValue([20,30,40,50])}).toNoteOnOff().take(5);\n// // var valToNoteTest = m.note({pitch:12,duration:20}).loop().set({velocity: m.value().loop().setValue([20,30,40,50])}).take(5);\n// // console.log(\"VAAAAALToNOOOTE3\",[for (e of valToNoteTest) e]);\n// //\n// // //return;\n// //\n// // var seqNewNew = m.note().loop().pitch([12,13,14]).set({bla:\"test\"}).take(5);\n// // console.log(\"\"+seqNewNew);\n// //\n// // var tsts = m.note().loop().pitch([12,13,14]).set({bla:\"test\"}).take(5);\n// //\n// // console.log(\"tststs\",\"\"+tsts);\n// //\n// // for (var n of tsts) {\n// //   console.log(\"tsts\",n);\n// // }\n// //\n// // //return;\n// //\n// // //var seqNewNew2 = m.note().repeat(10).pitch([3,4,5]).velocity(100).duration([20,10,10]).eventCount().timeFromDurations().filter((e) => e.count % 5 != 0);\n//\n// //\n// //\n// // var pitchMap=wu.curryable(function(pitches,node) {\n// //   return node.pitch(n => n.pitch+pitches[Math.floor(n.time/4%pitches.length)]);\n// // });\n// //\n// // var tPitchMap=pitchMap([2,0,3,4,-12,-5,12,12]);\n// // //var tPitchMap=pitchMap([0]);\n// //\n// // export var marimba2=tPitchMap(m.evt({pitch:50,duration:[0.2,0.1,0.3],color:\"red\",velocity:[0.9,0.7]})\n// // .metro(1)\n// // //.bjorklund(8,6,0)\n// // .automate(\"param1\", n => (n.time+n.evt.time) % 4 /4)\n// // .automate(\"pitchBend\", n => (n.time+n.evt.time) % 64 /64));\n// //\n// //\n// // var c=0;\n// // for (let e of marimba2.toPlayable()) {\n// //   c++;\n// //   if (c %500==0)\n// //     console.log(\"m2\",c,e);\n// //     if (c > 5000)\n// //       break;\n// //\n// //     }\n// //\n// // c=0;\n// //     for (let e of marimba2.toPlayable()) {\n// //       c++;\n// //       if (c %500==0)\n// //         console.log(\"m2\",c,e);\n// //         if (c > 5000)\n// //           break;\n// //         }\n// //         c=0;\n// //         for (let e of marimba2.toPlayable()) {\n// //           c++;\n// //           if (c %500==0)\n// //             console.log(\"m2\",c,e);\n// //             if (c > 5000)\n// //               break;\n// //             }\n// //\n// //             c=0;\n// //             for (let e of marimba2.toPlayable()) {\n// //               c++;\n// //               if (c %500==0)\n// //                 console.log(\"m2\",c,e);\n// //                 if (c > 5000)\n// //                   break;\n// //                 }\n// //                 c=0;\n","Object.defineProperties(exports, $__placeholder__0);","{get: $__placeholder__0}","get $__placeholder__0() { return $__placeholder__1; }","__esModule: true","{value: $__placeholder__0}","($__placeholder__0 = require($__placeholder__1),\n        $__placeholder__2 && $__placeholder__3.__esModule && $__placeholder__4 || {default: $__placeholder__5})","$__placeholder__0[$traceurRuntime.toProperty($__placeholder__1)]","\n        for (var $__placeholder__0 =\n                 $__placeholder__1[\n                     $traceurRuntime.toProperty(Symbol.iterator)](),\n                 $__placeholder__2;\n             !($__placeholder__3 = $__placeholder__4.next()).done; ) {\n          $__placeholder__5;\n          $__placeholder__6;\n        }"]}