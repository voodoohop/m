1	"\n\n\n\nexport var kick=m.evt({pitch:60, velocity:0.9, duration:0.5}).metro(0.25).bjorklund(16,9,1);//.notePlay();\n\n\n\n   \n// // import {Yegros_Transformed} from \"./externalSeq\";\n import {progression,bassprog,Yegros_Transformed,cesaria,ostinato} from \"./abletonClip\";\n\n\nexport var tst = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);\n// // console.log(Yegros_Transformed.take(50).toArray());\n\n// // throw \"bye\";\n\n// export var kick=m.evt({pitch:40, velocity:0.9, duration:0.5}).metro(1).notePlay();\n\n//export var failMe=m.data([{pitch:60, velocity:0.9, duration:5, time:0},{pitch:60, velocity:0.9, duration:1, time:2}]).notePlay().cache();\n\n// export var cowbell = m.evt({pitch:60, velocity: [0.8,0.5,0.3], duration:0.1})\n// .metro(0.25)\n\n// .bjorklund(16,9,0)\n// .swing(0.25, 0.05);\n\n\n\n\n\n\n// export var kick2=m.evt({pitch:60, velocity:0.9, duration:7}).metro(8).automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);//.notePlay().cache();\n\n\nexport var kick3=m.evt({pitch:[47,45], velocity:0.9, duration:0.2, color:[\"white\",\"orange\",\"red\"]}).metro(2/3).bjorklund(16,16,0);//.notePlay().cache();\n\nexport var kickMerged = kick3.merge(kick.pitch((n)=>n.pitch+12));    \n// export var kick4 = kick3.metro(0.5).merge(kick)\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25).delay(1);//.notePlay().cache();\n\n// export var kick5 = kick4.pitch(n => n.pitch -12);//.notePlay();\n\nexport var hat = m.evt({pitch:30, duration:0.2,velocity:[0.5,0.7,0.8]}).metro(0.25).bjorklund(16,6,0)\n.automate(\"param1\", (n) => {\n var period =2.5;\n     var easingFunc = easer().using(\"in-expo\");\n     var x = ((n.evt.time) % (period))/(period);\n    var prop = x;// easingFunc(x);\n return prop;\n})\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25)\n\n//  .swing(0.25,0.1)\n\n// .bjorklund(8,5,2)\n// .automate(\"param1\", (n) => {\n//  var period =2.5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param2\", (n) => {\n//  var period =4;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;//easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param3\", (n) => {\n//  var period = 5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// }); \n\n// .notePlay().cache();\n\n\nexport var hat3 = m.evt({pitch:60, duration:0.2,velocity:[0.5,0.7,0.8,0.6]}).metro(0.25).combineMap((c) => {\n    var sameTime = c.other.next && c.other.next.time == c.time;\n    var res=[{duration:0.1, velocity:  sameTime ? 0.4 : c.velocity, time:c.time, pitch: sameTime?c.pitch+12:c.pitch}];\n    var res2={duration:0.1, velocity:  0.5, time:c.time+0.25, pitch:c.pitch+12};\n    //console.log(\"REES\",res);\n    if (sameTime)\n        res.push(res2);\n    return res;\n},kick3)\n.swing(0.5,0.2)\n// .quantize(0.5,1)\n .delay(0.5)\n.durationsFromTime()\n.automate(\"param1\", (n) => {\n console.log(\"p1\",n);\n return easer().using(\"out-cubic\")(1-((n.time+n.evt.time) % (4))/(4));\n});\nconsole.log(\"tomtomtomtom\");\n\n//.notePlay().cache();\n\n\n\n// var getScale = (noteCount, offset) => m.count(0,1).bjorklund(12,noteCount,offset).takeWhile((n) => n<127);\n\n// var inScale = (scale, pitches) => _.intersection(scale, _.uniq(pitches)).length == _.uniq(pitches).length;\n\n\n// var transpose = -0;\n// var scaleNoteCount = 7;\n// var scaleOffset =0;\n\n// var melodyTranspose = 0;\n// // find scale\n\n//  var pitches = [61,66,57,64,56,61,61,63,64,64,56,61];\n// //var pitches = [53,69,65,61,50,57];\n// var melodyPitches = m.data(pitches);\n\n// var foundScale;\n\n//  console.log(\"PITCHES IN MELODY\",_.uniq(melodyPitches.toArray()));\n\n// for (scaleOffset=0; scaleOffset<12; scaleOffset++) {\n//     foundScale = getScale(scaleNoteCount, scaleOffset);\n//     if (inScale(foundScale.toArray(), pitches)) {\n//         console.log(\"fooound scale \"+foundScale);   \n//         break;\n//     }\n// }\n\n\n\n// var scale = foundScale;\n// var scaleArray = scale.toArray();\n// console.log(\"scaleArray \"+scale.toArray());\n\n\n\n\n// // // .map((n) => n+3)\n\n// var pitchesInScale = melodyPitches.map((n) => Math.floor(n*scaleNoteCount/12)).take(pitches.length);\n// //melodyPitches = melodyPitches.map((n) => scaleArray[Math.floor(n*scaleNoteCount/12)])\n\n// // // ;\n\n// var swingAmount = 0.1;\n// // var test1 = m.evt([{pitch:12},{pitch:13}]);\n\n// //  for (let p of melodyPitches.take(15))\n// //      console.log(\"melodyPitch\",p*scaleNoteCount/12);\n\n// var rootMelody = m.evt({pitch:pitchesInScale, duration:[1,0.5,0.5,1,0.5,0.5], velocity:[0.3,0.2,0.2,0.35]});\n\n// export var melody = rootMelody\n// .metro(1/4).duration((n) => n.duration / 2.1)\n// .bjorklund(16,9,2)\n//  .swing(0.25,swingAmount)\n// .pitch((n) => n.pitch+4+transpose)\n// .pitch((n) => scaleArray[n.pitch.valueOf()])\n// .notePlay();\n\n\n// // export var amelody = rootMelody\n\n// // .metro(4)\n\n// // .bjorklund(16,9,2)\n// // .durationsFromTime()\n// // // .swing(0.25,swingAmount)\n\n\n// //  //.map((n) => console.log(\"map\",n))\n// //  //.automate(\"pitchBend\")\n// // // .pitch((n) => n.pitch+4+transpose)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-2])\n// //  .withNext()\n \n \n// //  .map((n) => m.data(n.me).prop(\"nextTime\",n.next.time).take(1))\n\n// // console.log(\"AAAA\",amelody.take(5).toArray());\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n.combine(node.groupByTime().eventCount())\n//  .withNext()\n//  .map((n) => m.data(n.me).take(1))\n .automate(\"pitchBend\",(n) => {\n  //   console.log(\"PEEBEE\",n);\n    //  return 0.5;\n    if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n    }\n    var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n    var evtNo2 = Math.floor(n.evt.other.next.count/16);\n    var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n    var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n    var nextPitch = next.pitch.valueOf();\n    var prevPitch = prev.pitch.valueOf();\n    var mePitch=n.evt.pitch.valueOf();\n    //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n    var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n    \n  // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n    var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n    if (meLastDelta >6)\n      meLastDelta -=12;\n    // pitchNow=(96+pitchNow)%24-12;\n    // console.log((mePitch%24 - pitchNow)/24);   \n    var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n    if (meNextDelta >6)\n      meNextDelta -=12;\n    //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n   \n    var amplitude = 1;\n    var x= n.time/n.duration;\n    var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n    var easingFunc = easer().using(\"in-expo\");\n    var prop =easingFunc(xTransformed);\n  // prop = 0;\n    var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n //   console.log(\"res\",0.5 + nowDelta/12)\n    return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n }\n ).prop(\"pitchBend\", (n) => n.pitchBend );\n var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n .notePlay().merge(pbAuto.delay(delay));\n return res;\n};\n\nexport var melPBPlayer = pitchBendPlayer(ostinato,0,52,0.3,0,32).pitch((n) => n.pitch+12);\nexport var melPBPlayer2 = pitchBendPlayer(ostinato,1,52,0.5,0,32);\nexport var melPBPlayer3 = pitchBendPlayer(ostinato,0,52,0.4,0,32);\n//export var melPBPlayer3 = pitchBendPlayer(progression,3,50,0,0.5);\nexport var deeperPBPlayer = pitchBendPlayer(ostinato,0,62,0,0,1/6);\nexport var deeperPBPlayer2 = pitchBendPlayer(ostinato,0,54,0,0,1.5);\n//console.log(melPBPlayer.take(5).toArray());\n\n// // throw \"hi\";\n// // export var melody2 = rootMelody\n// // .metro(1/4)\n// // .duration((n) => n.duration / 2)\n// // .bjorklund(16,13,2)\n// //  .swing(0.25,swingAmount)\n\n// // // .delay(4.25)\n// // .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 7+transpose: c.pitch+11-transpose, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()])\n// // .notePlay();\n\n\n// export var melody4 = rootMelody\n// .metro(1)\n// .duration((n) => n.duration)\n// //.delay([0,0.5,1,2,3,4])\n\n \n\n//  .withNext()\n \n \n//  .map((n) => m.data(n.me).set({nextTime:n.next.time, nextPitch:n.next.pitch, myPitch:n.me.pitch, myTime: n.me.time}).take(1))\n//  .automate(\"pitchBend\",(n) => {\n\n//      //Math.min(n.nextTime-n.time,1));\n//     // console.log(\"hey\",n);\n//     var timeToNext = n.evt.nextTime - n.time- n.evt.myTime;\n//     // console.log(\"ttn\",timeToNext);\n//      if (timeToNext < 64) {\n//          var pitchNext = n.evt.nextPitch;\n//           var myPitch = n.evt.myPitch;\n//           var speed = 2;\n//           var totalDistance = (pitchNext-myPitch)/12*4/speed;\n//         //   var proportionTraveled = 1-timeToNext/32;\n//         //   console.log(\"proportionTraveled\", proportionTraveled);\n//           //console.log(Math.random()*proportionTraveled);\n//           var dist = n.evt.nextTime - n.evt.myTime;\n//          var propTraveled = 1-timeToNext/dist; \n//         //  if (propTraveled < 0.5 && propTraveled > -0.1)\n//         //     return (propTraveled/0.5)/40+0.5;\n//          var pb = Math.max(0,(propTraveled-1/speed))*totalDistance/2+0.5;\n//         //   console.log(\"propTraveled\",propTraveled,totalDistance,pb);\n          \n//          return pb;// * proportionTraveled;\n         \n//      }\n//      return 0.5;//Math.min(1,((timeToNext)%4/4));//Math.min(n.nextTime-n.time,1) \n// })\n// .pitch((n) => scaleArray[n.pitch.valueOf()+transpose])\n// .map((t) => [{time:t.time}, {time:t.time+1}, {time:t.time+1.5} , {time:t.time+2}, {time:t.time+2.5}, {time:t.time+3},{time:t.time+4}, {time:t.time+3.5} ])\n// .bjorklund(16,13,0)\n\n//  .swing(0.25,swingAmount)\n\n// // .delay(4.25)\n// .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? 41: c.pitch, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n\n// .notePlay();\n\n\n// // export var melody3 = rootMelody\n// // .metro(0.5)\n// // // .duration((n) => n.duration / 2)\n// // .bjorklund(8,3,1)\n// //  .swing(0.25,swingAmount)\n// // .pitch((n) => n.pitch-7)\n// // // .delay(4.25)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 3: c.pitch+4, velocity:sameTime ? c.velocity*0.8: c.velocity+0, duration: sameTime ? c.duration*4: c.duration*3}\n// // }, melody)\n// // .map((n) => [{pitch: n.pitch+3, time:n.time\n// // //+Math.random()*0.4-0.2\n// // }, {pitch: n.pitch}])\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-transpose])\n// // .velocity([0.5,0.7,0.5,0.3])\n\n// // .notePlay();\n\n\n// // export var pitchb3 = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .duration((n) => n.duration*0.9) \n// // .eventCount()\n// // .prop(\"pitchBend\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     //var timePassed2=1-(Math.abs(timePassed -0.5)*2);\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // })\n\n// //  .velocity(0.7)\n// // //  .pitch(60)\n\n// // // .pitch((n) => scaleArray[n.pitch.valueOf()-9])\n// // .notePlay()\n// // .automatePlay(\"pitchBend\")\n// // ;\n\n\n// // export var pitchb_concept_test = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .eventCount()\n// // .notePlay()\n// // .merge()\n// // .set(\"pitchBend\", (n) => m.evt({type:\"automation\"}).metro(1/128).set({value:}))\n// // .automatePlay(\"pitchBend_old\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // }).automatePlay(\"pitchBend\", );\n\n// // //console.log(\"PITCHBEND\",pitchbend.take(10).toArray());\n\n      "
1	"\n\n\n\nexport var kick=m.evt({pitch:60, velocity:0.9, duration:0.5}).metro(0.25).bjorklund(16,9,1);//.notePlay();\n\n\n\n   \n// // import {Yegros_Transformed} from \"./externalSeq\";\n import {progression,bassprog,Yegros_Transformed,cesaria,ostinato} from \"./abletonClip\";\n\n\nexport var tst = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);\n// // console.log(Yegros_Transformed.take(50).toArray());\n\n// // throw \"bye\";\n\n// export var kick=m.evt({pitch:40, velocity:0.9, duration:0.5}).metro(1).notePlay();\n\n//export var failMe=m.data([{pitch:60, velocity:0.9, duration:5, time:0},{pitch:60, velocity:0.9, duration:1, time:2}]).notePlay().cache();\n\n// export var cowbell = m.evt({pitch:60, velocity: [0.8,0.5,0.3], duration:0.1})\n// .metro(0.25)\n\n// .bjorklund(16,9,0)\n// .swing(0.25, 0.05);\n\n\n\n\n\n\n// export var kick2=m.evt({pitch:60, velocity:0.9, duration:7}).metro(8).automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);//.notePlay().cache();\n\n\nexport var kick3=m.evt({pitch:[47,45], velocity:0.9, duration:0.2, color:[\"white\",\"orange\",\"red\"]}).metro(2/3).bjorklund(16,16,0);//.notePlay().cache();\n\nexport var kickMerged = kick3.merge(kick.pitch((n)=>n.pitch+12));    \n// export var kick4 = kick3.metro(0.5).merge(kick)\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25).delay(1);//.notePlay().cache();\n\n// export var kick5 = kick4.pitch(n => n.pitch -12);//.notePlay();\n\nexport var hat = m.evt({pitch:30, duration:0.2,velocity:[0.5,0.7,0.8]}).metro(0.25).bjorklund(16,6,0)\n.automate(\"param1\", (n) => {\n var period =2.5;\n     var easingFunc = easer().using(\"in-expo\");\n     var x = ((n.evt.time) % (period))/(period);\n    var prop = x;// easingFunc(x);\n return prop;\n})\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25)\n\n//  .swing(0.25,0.1)\n\n// .bjorklund(8,5,2)\n// .automate(\"param1\", (n) => {\n//  var period =2.5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param2\", (n) => {\n//  var period =4;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;//easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param3\", (n) => {\n//  var period = 5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// }); \n\n// .notePlay().cache();\n\n\nexport var hat3 = m.evt({pitch:60, duration:0.2,velocity:[0.5,0.7,0.8,0.6]}).metro(0.25).combineMap((c) => {\n    var sameTime = c.other.next && c.other.next.time == c.time;\n    var res=[{duration:0.1, velocity:  sameTime ? 0.4 : c.velocity, time:c.time, pitch: sameTime?c.pitch+12:c.pitch}];\n    var res2={duration:0.1, velocity:  0.5, time:c.time+0.25, pitch:c.pitch+12};\n    //console.log(\"REES\",res);\n    if (sameTime)\n        res.push(res2);\n    return res;\n},kick3)\n.swing(0.5,0.2)\n// .quantize(0.5,1)\n .delay(0.5)\n.durationsFromTime()\n.automate(\"param1\", (n) => {\n console.log(\"p1\",n);\n return easer().using(\"out-cubic\")(1-((n.time+n.evt.time) % (4))/(4));\n});\nconsole.log(\"tomtomtomtom\");\n\n//.notePlay().cache();\n\n\n\n// var getScale = (noteCount, offset) => m.count(0,1).bjorklund(12,noteCount,offset).takeWhile((n) => n<127);\n\n// var inScale = (scale, pitches) => _.intersection(scale, _.uniq(pitches)).length == _.uniq(pitches).length;\n\n\n// var transpose = -0;\n// var scaleNoteCount = 7;\n// var scaleOffset =0;\n\n// var melodyTranspose = 0;\n// // find scale\n\n//  var pitches = [61,66,57,64,56,61,61,63,64,64,56,61];\n// //var pitches = [53,69,65,61,50,57];\n// var melodyPitches = m.data(pitches);\n\n// var foundScale;\n\n//  console.log(\"PITCHES IN MELODY\",_.uniq(melodyPitches.toArray()));\n\n// for (scaleOffset=0; scaleOffset<12; scaleOffset++) {\n//     foundScale = getScale(scaleNoteCount, scaleOffset);\n//     if (inScale(foundScale.toArray(), pitches)) {\n//         console.log(\"fooound scale \"+foundScale);   \n//         break;\n//     }\n// }\n\n\n\n// var scale = foundScale;\n// var scaleArray = scale.toArray();\n// console.log(\"scaleArray \"+scale.toArray());\n\n\n\n\n// // // .map((n) => n+3)\n\n// var pitchesInScale = melodyPitches.map((n) => Math.floor(n*scaleNoteCount/12)).take(pitches.length);\n// //melodyPitches = melodyPitches.map((n) => scaleArray[Math.floor(n*scaleNoteCount/12)])\n\n// // // ;\n\n// var swingAmount = 0.1;\n// // var test1 = m.evt([{pitch:12},{pitch:13}]);\n\n// //  for (let p of melodyPitches.take(15))\n// //      console.log(\"melodyPitch\",p*scaleNoteCount/12);\n\n// var rootMelody = m.evt({pitch:pitchesInScale, duration:[1,0.5,0.5,1,0.5,0.5], velocity:[0.3,0.2,0.2,0.35]});\n\n// export var melody = rootMelody\n// .metro(1/4).duration((n) => n.duration / 2.1)\n// .bjorklund(16,9,2)\n//  .swing(0.25,swingAmount)\n// .pitch((n) => n.pitch+4+transpose)\n// .pitch((n) => scaleArray[n.pitch.valueOf()])\n// .notePlay();\n\n\n// // export var amelody = rootMelody\n\n// // .metro(4)\n\n// // .bjorklund(16,9,2)\n// // .durationsFromTime()\n// // // .swing(0.25,swingAmount)\n\n\n// //  //.map((n) => console.log(\"map\",n))\n// //  //.automate(\"pitchBend\")\n// // // .pitch((n) => n.pitch+4+transpose)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-2])\n// //  .withNext()\n \n \n// //  .map((n) => m.data(n.me).prop(\"nextTime\",n.next.time).take(1))\n\n// // console.log(\"AAAA\",amelody.take(5).toArray());\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n.combine(node.groupByTime().eventCount())\n//  .withNext()\n//  .map((n) => m.data(n.me).take(1))\n .automate(\"pitchBend\",(n) => {\n  //   console.log(\"PEEBEE\",n);\n    //  return 0.5;\n    if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n    }\n    var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n    var evtNo2 = Math.floor(n.evt.other.next.count/16);\n    var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n    var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n    var nextPitch = next.pitch.valueOf();\n    var prevPitch = prev.pitch.valueOf();\n    var mePitch=n.evt.pitch.valueOf();\n    //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n    var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n    \n  // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n    var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n    if (meLastDelta >6)\n      meLastDelta -=12;\n    // pitchNow=(96+pitchNow)%24-12;\n    // console.log((mePitch%24 - pitchNow)/24);   \n    var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n    if (meNextDelta >6)\n      meNextDelta -=12;\n    //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n   \n    var amplitude = 1;\n    var x= n.time/n.duration;\n    var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n    var easingFunc = easer().using(\"in-expo\");\n    var prop =easingFunc(xTransformed);\n  // prop = 0;\n    var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n //   console.log(\"res\",0.5 + nowDelta/12)\n    return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n }\n ).prop(\"pitchBend\", (n) => n.pitchBend );\n var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n .notePlay().merge(pbAuto.delay(delay));\n return res;\n};\n\nexport var melPBPlayer = pitchBendPlayer(ostinato,0,52,0.3,0,32).pitch((n) => n.pitch+12);\nexport var melPBPlayer2 = pitchBendPlayer(ostinato,1,52,0.5,0,32);\nexport var melPBPlayer3 = pitchBendPlayer(ostinato,0,52,0.4,0,32);\n//export var melPBPlayer3 = pitchBendPlayer(progression,3,50,0,0.5);\nexport var deeperPBPlayer = pitchBendPlayer(ostinato,0,62,0,0,1/6);\nexport var deeperPBPlayer2 = pitchBendPlayer(ostinato,0,54,0,0,1.5);\n//console.log(melPBPlayer.take(5).toArray());\n\n// // throw \"hi\";\n// // export var melody2 = rootMelody\n// // .metro(1/4)\n// // .duration((n) => n.duration / 2)\n// // .bjorklund(16,13,2)\n// //  .swing(0.25,swingAmount)\n\n// // // .delay(4.25)\n// // .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 7+transpose: c.pitch+11-transpose, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()])\n// // .notePlay();\n\n\n// export var melody4 = rootMelody\n// .metro(1)\n// .duration((n) => n.duration)\n// //.delay([0,0.5,1,2,3,4])\n\n \n\n//  .withNext()\n \n \n//  .map((n) => m.data(n.me).set({nextTime:n.next.time, nextPitch:n.next.pitch, myPitch:n.me.pitch, myTime: n.me.time}).take(1))\n//  .automate(\"pitchBend\",(n) => {\n\n//      //Math.min(n.nextTime-n.time,1));\n//     // console.log(\"hey\",n);\n//     var timeToNext = n.evt.nextTime - n.time- n.evt.myTime;\n//     // console.log(\"ttn\",timeToNext);\n//      if (timeToNext < 64) {\n//          var pitchNext = n.evt.nextPitch;\n//           var myPitch = n.evt.myPitch;\n//           var speed = 2;\n//           var totalDistance = (pitchNext-myPitch)/12*4/speed;\n//         //   var proportionTraveled = 1-timeToNext/32;\n//         //   console.log(\"proportionTraveled\", proportionTraveled);\n//           //console.log(Math.random()*proportionTraveled);\n//           var dist = n.evt.nextTime - n.evt.myTime;\n//          var propTraveled = 1-timeToNext/dist; \n//         //  if (propTraveled < 0.5 && propTraveled > -0.1)\n//         //     return (propTraveled/0.5)/40+0.5;\n//          var pb = Math.max(0,(propTraveled-1/speed))*totalDistance/2+0.5;\n//         //   console.log(\"propTraveled\",propTraveled,totalDistance,pb);\n          \n//          return pb;// * proportionTraveled;\n         \n//      }\n//      return 0.5;//Math.min(1,((timeToNext)%4/4));//Math.min(n.nextTime-n.time,1) \n// })\n// .pitch((n) => scaleArray[n.pitch.valueOf()+transpose])\n// .map((t) => [{time:t.time}, {time:t.time+1}, {time:t.time+1.5} , {time:t.time+2}, {time:t.time+2.5}, {time:t.time+3},{time:t.time+4}, {time:t.time+3.5} ])\n// .bjorklund(16,13,0)\n\n//  .swing(0.25,swingAmount)\n\n// // .delay(4.25)\n// .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? 41: c.pitch, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n\n// .notePlay();\n\n\n// // export var melody3 = rootMelody\n// // .metro(0.5)\n// // // .duration((n) => n.duration / 2)\n// // .bjorklund(8,3,1)\n// //  .swing(0.25,swingAmount)\n// // .pitch((n) => n.pitch-7)\n// // // .delay(4.25)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 3: c.pitch+4, velocity:sameTime ? c.velocity*0.8: c.velocity+0, duration: sameTime ? c.duration*4: c.duration*3}\n// // }, melody)\n// // .map((n) => [{pitch: n.pitch+3, time:n.time\n// // //+Math.random()*0.4-0.2\n// // }, {pitch: n.pitch}])\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-transpose])\n// // .velocity([0.5,0.7,0.5,0.3])\n\n// // .notePlay();\n\n\n// // export var pitchb3 = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .duration((n) => n.duration*0.9) \n// // .eventCount()\n// // .prop(\"pitchBend\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     //var timePassed2=1-(Math.abs(timePassed -0.5)*2);\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // })\n\n// //  .velocity(0.7)\n// // //  .pitch(60)\n\n// // // .pitch((n) => scaleArray[n.pitch.valueOf()-9])\n// // .notePlay()\n// // .automatePlay(\"pitchBend\")\n// // ;\n\n\n// // export var pitchb_concept_test = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .eventCount()\n// // .notePlay()\n// // .merge()\n// // .set(\"pitchBend\", (n) => m.evt({type:\"automation\"}).metro(1/128).set({value:}))\n// // .automatePlay(\"pitchBend_old\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // }).automatePlay(\"pitchBend\", );\n\n// // //console.log(\"PITCHBEND\",pitchbend.take(10).toArray());\n\n      "
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\nvar scale = teoria.scale(\"g\",\"minor\");\n\nconsole.log(scale);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\nconsole.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\nvar scale = teoria.scale(\"g\",\"minor\");\n\nconsole.log(scale);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\nconsole.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\nvar scale = teoria.scale(\"g\",\"minor\");\n\nconsole.log(scale.notes());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\nconsole.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key);\n\n\nconsole.log(scaleNotes);\n\nvar melodyTheme = \n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\nconsole.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key);\n\n\nconsole.log(scaleNotes);\n\nvar melodyTheme = \n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\nconsole.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key);\n\n\nconsole.log(scaleNotes);\n\n// var melodyTheme = \n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\nconsole.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key);\n\n\nconsole.log(scaleNotes);\n\n// var melodyTheme = \n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\nconsole.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key);\n\n\nconsole.log(\"scaleNotes\",scaleNotes);\n\n// var melodyTheme = \n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\nconsole.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\nconsole.log(\"scaleNotes\",scaleNotes);\n\n// var melodyTheme = \n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\nconsole.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\n// var scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\n// console.log(\"scaleNotes\",scaleNotes);\n\n// var melodyTheme = \n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\nconsole.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\n// var scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\n// console.log(\"scaleNotes\",scaleNotes);\n\n// var melodyTheme = \n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\n// var chordProgMap = (n) => {\n//   var barNo = Math.floor(n.time / t.bars(1));\n//   var currentChord = teoria.chord(chordProg[barNo % chordProg.length]);\n//   var chordNotes = currentChord.notes().map( note => note.key());\n//   var prevNote = n.pitch;\n//   var transformedNote = chordNotes[(prevNote-64+(chordNotes.length*1000))%chordNotes.length]+12*Math.floor((prevNote-64)/chordNotes.length);\n//   return {pitch:transformedNote};\n// };\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\nconsole.log(\"scaleNotes\",scaleNotes);\n\n// var melodyTheme = \n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = (notes, note) => ({pitch: notesotes[(note.pitch-60+(notes.length*1000))%chordNotes.length]*Math.floor((note.pitch-60)/notes.length)});\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\n\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = (notes, note) => ({pitch: notesotes[(note.pitch-60+(notes.length*1000))%chordNotes.length]*Math.floor((note.pitch-60)/notes.length)});\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch:n[1], duration:1, time:n[0]}))).loopLength(8);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
1	"\n\n\n\nexport var kick=m.evt({pitch:60, velocity:0.9, duration:0.5}).metro(0.25).bjorklund(16,9,1);//.notePlay();\n\n\n\n   \n// // import {Yegros_Transformed} from \"./externalSeq\";\n import {progression,bassprog,Yegros_Transformed,cesaria,ostinato} from \"./abletonClip\";\n\n\nexport var tst = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);\n// // console.log(Yegros_Transformed.take(50).toArray());\n\n// // throw \"bye\";\n\n// export var kick=m.evt({pitch:40, velocity:0.9, duration:0.5}).metro(1).notePlay();\n\n//export var failMe=m.data([{pitch:60, velocity:0.9, duration:5, time:0},{pitch:60, velocity:0.9, duration:1, time:2}]).notePlay().cache();\n\n// export var cowbell = m.evt({pitch:60, velocity: [0.8,0.5,0.3], duration:0.1})\n// .metro(0.25)\n\n// .bjorklund(16,9,0)\n// .swing(0.25, 0.05);\n\n\n\n\n\n\n// export var kick2=m.evt({pitch:60, velocity:0.9, duration:7}).metro(8).automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);//.notePlay().cache();\n\n\nexport var kick3=m.evt({pitch:[47,45], velocity:0.9, duration:0.2, color:[\"white\",\"orange\",\"red\"]}).metro(2/3).bjorklund(16,16,0);//.notePlay().cache();\n\nexport var kickMerged = kick3.merge(kick.pitch((n)=>n.pitch+12));    \n// export var kick4 = kick3.metro(0.5).merge(kick)\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25).delay(1);//.notePlay().cache();\n\n// export var kick5 = kick4.pitch(n => n.pitch -12);//.notePlay();\n\nexport var hat = m.evt({pitch:30, duration:0.2,velocity:[0.5,0.7,0.8]}).metro(0.25).bjorklund(16,6,0)\n.automate(\"param1\", (n) => {\n var period =2.5;\n     var easingFunc = easer().using(\"in-expo\");\n     var x = ((n.evt.time) % (period))/(period);\n    var prop = x;// easingFunc(x);\n return prop;\n})\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25)\n\n//  .swing(0.25,0.1)\n\n// .bjorklund(8,5,2)\n// .automate(\"param1\", (n) => {\n//  var period =2.5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param2\", (n) => {\n//  var period =4;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;//easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param3\", (n) => {\n//  var period = 5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// }); \n\n// .notePlay().cache();\n\n\nexport var hat3 = m.evt({pitch:60, duration:0.2,velocity:[0.5,0.7,0.8,0.6]}).metro(0.25).combineMap((c) => {\n    var sameTime = c.other.next && c.other.next.time == c.time;\n    var res=[{duration:0.1, velocity:  sameTime ? 0.4 : c.velocity, time:c.time, pitch: sameTime?c.pitch+12:c.pitch}];\n    var res2={duration:0.1, velocity:  0.5, time:c.time+0.25, pitch:c.pitch+12};\n    //console.log(\"REES\",res);\n    if (sameTime)\n        res.push(res2);\n    return res;\n},kick3)\n.swing(0.5,0.2)\n// .quantize(0.5,1)\n .delay(0.5)\n.durationsFromTime()\n.automate(\"param1\", (n) => {\n console.log(\"p1\",n);\n return easer().using(\"out-cubic\")(1-((n.time+n.evt.time) % (4))/(4));\n});\nconsole.log(\"tomtomtomtom\");\n\n//.notePlay().cache();\n\n\n\n// var getScale = (noteCount, offset) => m.count(0,1).bjorklund(12,noteCount,offset).takeWhile((n) => n<127);\n\n// var inScale = (scale, pitches) => _.intersection(scale, _.uniq(pitches)).length == _.uniq(pitches).length;\n\n\n// var transpose = -0;\n// var scaleNoteCount = 7;\n// var scaleOffset =0;\n\n// var melodyTranspose = 0;\n// // find scale\n\n//  var pitches = [61,66,57,64,56,61,61,63,64,64,56,61];\n// //var pitches = [53,69,65,61,50,57];\n// var melodyPitches = m.data(pitches);\n\n// var foundScale;\n\n//  console.log(\"PITCHES IN MELODY\",_.uniq(melodyPitches.toArray()));\n\n// for (scaleOffset=0; scaleOffset<12; scaleOffset++) {\n//     foundScale = getScale(scaleNoteCount, scaleOffset);\n//     if (inScale(foundScale.toArray(), pitches)) {\n//         console.log(\"fooound scale \"+foundScale);   \n//         break;\n//     }\n// }\n\n\n\n// var scale = foundScale;\n// var scaleArray = scale.toArray();\n// console.log(\"scaleArray \"+scale.toArray());\n\n\n\n\n// // // .map((n) => n+3)\n\n// var pitchesInScale = melodyPitches.map((n) => Math.floor(n*scaleNoteCount/12)).take(pitches.length);\n// //melodyPitches = melodyPitches.map((n) => scaleArray[Math.floor(n*scaleNoteCount/12)])\n\n// // // ;\n\n// var swingAmount = 0.1;\n// // var test1 = m.evt([{pitch:12},{pitch:13}]);\n\n// //  for (let p of melodyPitches.take(15))\n// //      console.log(\"melodyPitch\",p*scaleNoteCount/12);\n\n// var rootMelody = m.evt({pitch:pitchesInScale, duration:[1,0.5,0.5,1,0.5,0.5], velocity:[0.3,0.2,0.2,0.35]});\n\n// export var melody = rootMelody\n// .metro(1/4).duration((n) => n.duration / 2.1)\n// .bjorklund(16,9,2)\n//  .swing(0.25,swingAmount)\n// .pitch((n) => n.pitch+4+transpose)\n// .pitch((n) => scaleArray[n.pitch.valueOf()])\n// .notePlay();\n\n\n// // export var amelody = rootMelody\n\n// // .metro(4)\n\n// // .bjorklund(16,9,2)\n// // .durationsFromTime()\n// // // .swing(0.25,swingAmount)\n\n\n// //  //.map((n) => console.log(\"map\",n))\n// //  //.automate(\"pitchBend\")\n// // // .pitch((n) => n.pitch+4+transpose)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-2])\n// //  .withNext()\n \n \n// //  .map((n) => m.data(n.me).prop(\"nextTime\",n.next.time).take(1))\n\n// // console.log(\"AAAA\",amelody.take(5).toArray());\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n.combine(node.groupByTime().eventCount())\n//  .withNext()\n//  .map((n) => m.data(n.me).take(1))\n .automate(\"pitchBend\",(n) => {\n  //   console.log(\"PEEBEE\",n);\n    //  return 0.5;\n    if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n    }\n    var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n    var evtNo2 = Math.floor(n.evt.other.next.count/16);\n    var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n    var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n    var nextPitch = next.pitch.valueOf();\n    var prevPitch = prev.pitch.valueOf();\n    var mePitch=n.evt.pitch.valueOf();\n    //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n    var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n    \n  // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n    var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n    if (meLastDelta >6)\n      meLastDelta -=12;\n    // pitchNow=(96+pitchNow)%24-12;\n    // console.log((mePitch%24 - pitchNow)/24);   \n    var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n    if (meNextDelta >6)\n      meNextDelta -=12;\n    //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n   \n    var amplitude = 1;\n    var x= n.time/n.duration;\n    var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n    var easingFunc = easer().using(\"in-expo\");\n    var prop =easingFunc(xTransformed);\n  // prop = 0;\n    var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n //   console.log(\"res\",0.5 + nowDelta/12)\n    return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n }\n ).prop(\"pitchBend\", (n) => n.pitchBend );\n var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n .notePlay().merge(pbAuto.delay(delay));\n return res;\n};\n\nexport var melPBPlayer = pitchBendPlayer(ostinato,0,52,0.3,0,32).pitch((n) => n.pitch+12);\nexport var melPBPlayer2 = pitchBendPlayer(ostinato,1,52,0.5,0,32);\nexport var melPBPlayer3 = pitchBendPlayer(ostinato,0,52,0.4,0,32);\n//export var melPBPlayer3 = pitchBendPlayer(progression,3,50,0,0.5);\nexport var deeperPBPlayer = pitchBendPlayer(ostinato,0,62,0,0,1/6);\nexport var deeperPBPlayer2 = pitchBendPlayer(ostinato,0,54,0,0,1.5);\n//console.log(melPBPlayer.take(5).toArray());\n\n// // throw \"hi\";\n// // export var melody2 = rootMelody\n// // .metro(1/4)\n// // .duration((n) => n.duration / 2)\n// // .bjorklund(16,13,2)\n// //  .swing(0.25,swingAmount)\n\n// // // .delay(4.25)\n// // .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 7+transpose: c.pitch+11-transpose, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()])\n// // .notePlay();\n\n\n// export var melody4 = rootMelody\n// .metro(1)\n// .duration((n) => n.duration)\n// //.delay([0,0.5,1,2,3,4])\n\n \n\n//  .withNext()\n \n \n//  .map((n) => m.data(n.me).set({nextTime:n.next.time, nextPitch:n.next.pitch, myPitch:n.me.pitch, myTime: n.me.time}).take(1))\n//  .automate(\"pitchBend\",(n) => {\n\n//      //Math.min(n.nextTime-n.time,1));\n//     // console.log(\"hey\",n);\n//     var timeToNext = n.evt.nextTime - n.time- n.evt.myTime;\n//     // console.log(\"ttn\",timeToNext);\n//      if (timeToNext < 64) {\n//          var pitchNext = n.evt.nextPitch;\n//           var myPitch = n.evt.myPitch;\n//           var speed = 2;\n//           var totalDistance = (pitchNext-myPitch)/12*4/speed;\n//         //   var proportionTraveled = 1-timeToNext/32;\n//         //   console.log(\"proportionTraveled\", proportionTraveled);\n//           //console.log(Math.random()*proportionTraveled);\n//           var dist = n.evt.nextTime - n.evt.myTime;\n//          var propTraveled = 1-timeToNext/dist; \n//         //  if (propTraveled < 0.5 && propTraveled > -0.1)\n//         //     return (propTraveled/0.5)/40+0.5;\n//          var pb = Math.max(0,(propTraveled-1/speed))*totalDistance/2+0.5;\n//         //   console.log(\"propTraveled\",propTraveled,totalDistance,pb);\n          \n//          return pb;// * proportionTraveled;\n         \n//      }\n//      return 0.5;//Math.min(1,((timeToNext)%4/4));//Math.min(n.nextTime-n.time,1) \n// })\n// .pitch((n) => scaleArray[n.pitch.valueOf()+transpose])\n// .map((t) => [{time:t.time}, {time:t.time+1}, {time:t.time+1.5} , {time:t.time+2}, {time:t.time+2.5}, {time:t.time+3},{time:t.time+4}, {time:t.time+3.5} ])\n// .bjorklund(16,13,0)\n\n//  .swing(0.25,swingAmount)\n\n// // .delay(4.25)\n// .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? 41: c.pitch, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n\n// .notePlay();\n\n\n// // export var melody3 = rootMelody\n// // .metro(0.5)\n// // // .duration((n) => n.duration / 2)\n// // .bjorklund(8,3,1)\n// //  .swing(0.25,swingAmount)\n// // .pitch((n) => n.pitch-7)\n// // // .delay(4.25)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 3: c.pitch+4, velocity:sameTime ? c.velocity*0.8: c.velocity+0, duration: sameTime ? c.duration*4: c.duration*3}\n// // }, melody)\n// // .map((n) => [{pitch: n.pitch+3, time:n.time\n// // //+Math.random()*0.4-0.2\n// // }, {pitch: n.pitch}])\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-transpose])\n// // .velocity([0.5,0.7,0.5,0.3])\n\n// // .notePlay();\n\n\n// // export var pitchb3 = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .duration((n) => n.duration*0.9) \n// // .eventCount()\n// // .prop(\"pitchBend\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     //var timePassed2=1-(Math.abs(timePassed -0.5)*2);\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // })\n\n// //  .velocity(0.7)\n// // //  .pitch(60)\n\n// // // .pitch((n) => scaleArray[n.pitch.valueOf()-9])\n// // .notePlay()\n// // .automatePlay(\"pitchBend\")\n// // ;\n\n\n// // export var pitchb_concept_test = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .eventCount()\n// // .notePlay()\n// // .merge()\n// // .set(\"pitchBend\", (n) => m.evt({type:\"automation\"}).metro(1/128).set({value:}))\n// // .automatePlay(\"pitchBend_old\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // }).automatePlay(\"pitchBend\", );\n\n// // //console.log(\"PITCHBEND\",pitchbend.take(10).toArray());\n\n      "
1	"\n\n\n\nexport var kick=m.evt({pitch:60, velocity:0.9, duration:0.5}).metro(0.25).bjorklund(16,9,1);//.notePlay();\n\n\n\n   \n// // import {Yegros_Transformed} from \"./externalSeq\";\n import {progression,bassprog,Yegros_Transformed,cesaria,ostinato} from \"./abletonClip\";\n\n\nexport var tst = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);\n// // console.log(Yegros_Transformed.take(50).toArray());\n\n// // throw \"bye\";\n\n// export var kick=m.evt({pitch:40, velocity:0.9, duration:0.5}).metro(1).notePlay();\n\n//export var failMe=m.data([{pitch:60, velocity:0.9, duration:5, time:0},{pitch:60, velocity:0.9, duration:1, time:2}]).notePlay().cache();\n\n// export var cowbell = m.evt({pitch:60, velocity: [0.8,0.5,0.3], duration:0.1})\n// .metro(0.25)\n\n// .bjorklund(16,9,0)\n// .swing(0.25, 0.05);\n\n\n\n\n\n\n// export var kick2=m.evt({pitch:60, velocity:0.9, duration:7}).metro(8).automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);//.notePlay().cache();\n\n\nexport var kick3=m.evt({pitch:[47,45], velocity:0.9, duration:0.2, color:[\"white\",\"orange\",\"red\"]}).metro(2/3).bjorklund(16,16,0);//.notePlay().cache();\n\nexport var kickMerged = kick3.merge(kick.pitch((n)=>n.pitch+12));    \n// export var kick4 = kick3.metro(0.5).merge(kick)\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25).delay(1);//.notePlay().cache();\n\n// export var kick5 = kick4.pitch(n => n.pitch -12);//.notePlay();\n\nexport var hat = m.evt({pitch:30, duration:0.2,velocity:[0.5,0.7,0.8]}).metro(0.25).bjorklund(16,6,0)\n.automate(\"param1\", (n) => {\n var period =2.5;\n     var easingFunc = easer().using(\"in-expo\");\n     var x = ((n.evt.time) % (period))/(period);\n    var prop = x;// easingFunc(x);\n return prop;\n})\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25)\n\n//  .swing(0.25,0.1)\n\n// .bjorklund(8,5,2)\n// .automate(\"param1\", (n) => {\n//  var period =2.5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param2\", (n) => {\n//  var period =4;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;//easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param3\", (n) => {\n//  var period = 5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// }); \n\n// .notePlay().cache();\n\n\nexport var hat3 = m.evt({pitch:60, duration:0.2,velocity:[0.5,0.7,0.8,0.6]}).metro(0.25).combineMap((c) => {\n    var sameTime = c.other.next && c.other.next.time == c.time;\n    var res=[{duration:0.1, velocity:  sameTime ? 0.4 : c.velocity, time:c.time, pitch: sameTime?c.pitch+12:c.pitch}];\n    var res2={duration:0.1, velocity:  0.5, time:c.time+0.25, pitch:c.pitch+12};\n    //console.log(\"REES\",res);\n    if (sameTime)\n        res.push(res2);\n    return res;\n},kick3)\n.swing(0.5,0.2)\n// .quantize(0.5,1)\n .delay(0.5)\n.durationsFromTime()\n.automate(\"param1\", (n) => {\n console.log(\"p1\",n);\n return easer().using(\"out-cubic\")(1-((n.time+n.evt.time) % (4))/(4));\n});\nconsole.log(\"tomtomtomtom\");\n\n//.notePlay().cache();\n\n\n\n// var getScale = (noteCount, offset) => m.count(0,1).bjorklund(12,noteCount,offset).takeWhile((n) => n<127);\n\n// var inScale = (scale, pitches) => _.intersection(scale, _.uniq(pitches)).length == _.uniq(pitches).length;\n\n\n// var transpose = -0;\n// var scaleNoteCount = 7;\n// var scaleOffset =0;\n\n// var melodyTranspose = 0;\n// // find scale\n\n//  var pitches = [61,66,57,64,56,61,61,63,64,64,56,61];\n// //var pitches = [53,69,65,61,50,57];\n// var melodyPitches = m.data(pitches);\n\n// var foundScale;\n\n//  console.log(\"PITCHES IN MELODY\",_.uniq(melodyPitches.toArray()));\n\n// for (scaleOffset=0; scaleOffset<12; scaleOffset++) {\n//     foundScale = getScale(scaleNoteCount, scaleOffset);\n//     if (inScale(foundScale.toArray(), pitches)) {\n//         console.log(\"fooound scale \"+foundScale);   \n//         break;\n//     }\n// }\n\n\n\n// var scale = foundScale;\n// var scaleArray = scale.toArray();\n// console.log(\"scaleArray \"+scale.toArray());\n\n\n\n\n// // // .map((n) => n+3)\n\n// var pitchesInScale = melodyPitches.map((n) => Math.floor(n*scaleNoteCount/12)).take(pitches.length);\n// //melodyPitches = melodyPitches.map((n) => scaleArray[Math.floor(n*scaleNoteCount/12)])\n\n// // // ;\n\n// var swingAmount = 0.1;\n// // var test1 = m.evt([{pitch:12},{pitch:13}]);\n\n// //  for (let p of melodyPitches.take(15))\n// //      console.log(\"melodyPitch\",p*scaleNoteCount/12);\n\n// var rootMelody = m.evt({pitch:pitchesInScale, duration:[1,0.5,0.5,1,0.5,0.5], velocity:[0.3,0.2,0.2,0.35]});\n\n// export var melody = rootMelody\n// .metro(1/4).duration((n) => n.duration / 2.1)\n// .bjorklund(16,9,2)\n//  .swing(0.25,swingAmount)\n// .pitch((n) => n.pitch+4+transpose)\n// .pitch((n) => scaleArray[n.pitch.valueOf()])\n// .notePlay();\n\n\n// // export var amelody = rootMelody\n\n// // .metro(4)\n\n// // .bjorklund(16,9,2)\n// // .durationsFromTime()\n// // // .swing(0.25,swingAmount)\n\n\n// //  //.map((n) => console.log(\"map\",n))\n// //  //.automate(\"pitchBend\")\n// // // .pitch((n) => n.pitch+4+transpose)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-2])\n// //  .withNext()\n \n \n// //  .map((n) => m.data(n.me).prop(\"nextTime\",n.next.time).take(1))\n\n// // console.log(\"AAAA\",amelody.take(5).toArray());\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n.combine(node.groupByTime().eventCount())\n//  .withNext()\n//  .map((n) => m.data(n.me).take(1))\n .automate(\"pitchBend\",(n) => {\n  //   console.log(\"PEEBEE\",n);\n    //  return 0.5;\n    if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n    }\n    var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n    var evtNo2 = Math.floor(n.evt.other.next.count/16);\n    var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n    var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n    var nextPitch = next.pitch.valueOf();\n    var prevPitch = prev.pitch.valueOf();\n    var mePitch=n.evt.pitch.valueOf();\n    //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n    var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n    \n  // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n    var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n    if (meLastDelta >6)\n      meLastDelta -=12;\n    // pitchNow=(96+pitchNow)%24-12;\n    // console.log((mePitch%24 - pitchNow)/24);   \n    var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n    if (meNextDelta >6)\n      meNextDelta -=12;\n    //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n   \n    var amplitude = 1;\n    var x= n.time/n.duration;\n    var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n    var easingFunc = easer().using(\"in-expo\");\n    var prop =easingFunc(xTransformed);\n  // prop = 0;\n    var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n //   console.log(\"res\",0.5 + nowDelta/12)\n    return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n }\n ).prop(\"pitchBend\", (n) => n.pitchBend );\n var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n .notePlay().merge(pbAuto.delay(delay));\n return res;\n};\n\nexport var melPBPlayer = pitchBendPlayer(ostinato,0,52,0.3,0,32).pitch((n) => n.pitch+12);\nexport var melPBPlayer2 = pitchBendPlayer(ostinato,1,52,0.5,0,32);\nexport var melPBPlayer3 = pitchBendPlayer(ostinato,0,52,0.4,0,32);\n//export var melPBPlayer3 = pitchBendPlayer(progression,3,50,0,0.5);\nexport var deeperPBPlayer = pitchBendPlayer(ostinato,0,62,0,0,1/6);\nexport var deeperPBPlayer2 = pitchBendPlayer(ostinato,0,54,0,0,1.5);\n//console.log(melPBPlayer.take(5).toArray());\n\n// // throw \"hi\";\n// // export var melody2 = rootMelody\n// // .metro(1/4)\n// // .duration((n) => n.duration / 2)\n// // .bjorklund(16,13,2)\n// //  .swing(0.25,swingAmount)\n\n// // // .delay(4.25)\n// // .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 7+transpose: c.pitch+11-transpose, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()])\n// // .notePlay();\n\n\n// export var melody4 = rootMelody\n// .metro(1)\n// .duration((n) => n.duration)\n// //.delay([0,0.5,1,2,3,4])\n\n \n\n//  .withNext()\n \n \n//  .map((n) => m.data(n.me).set({nextTime:n.next.time, nextPitch:n.next.pitch, myPitch:n.me.pitch, myTime: n.me.time}).take(1))\n//  .automate(\"pitchBend\",(n) => {\n\n//      //Math.min(n.nextTime-n.time,1));\n//     // console.log(\"hey\",n);\n//     var timeToNext = n.evt.nextTime - n.time- n.evt.myTime;\n//     // console.log(\"ttn\",timeToNext);\n//      if (timeToNext < 64) {\n//          var pitchNext = n.evt.nextPitch;\n//           var myPitch = n.evt.myPitch;\n//           var speed = 2;\n//           var totalDistance = (pitchNext-myPitch)/12*4/speed;\n//         //   var proportionTraveled = 1-timeToNext/32;\n//         //   console.log(\"proportionTraveled\", proportionTraveled);\n//           //console.log(Math.random()*proportionTraveled);\n//           var dist = n.evt.nextTime - n.evt.myTime;\n//          var propTraveled = 1-timeToNext/dist; \n//         //  if (propTraveled < 0.5 && propTraveled > -0.1)\n//         //     return (propTraveled/0.5)/40+0.5;\n//          var pb = Math.max(0,(propTraveled-1/speed))*totalDistance/2+0.5;\n//         //   console.log(\"propTraveled\",propTraveled,totalDistance,pb);\n          \n//          return pb;// * proportionTraveled;\n         \n//      }\n//      return 0.5;//Math.min(1,((timeToNext)%4/4));//Math.min(n.nextTime-n.time,1) \n// })\n// .pitch((n) => scaleArray[n.pitch.valueOf()+transpose])\n// .map((t) => [{time:t.time}, {time:t.time+1}, {time:t.time+1.5} , {time:t.time+2}, {time:t.time+2.5}, {time:t.time+3},{time:t.time+4}, {time:t.time+3.5} ])\n// .bjorklund(16,13,0)\n\n//  .swing(0.25,swingAmount)\n\n// // .delay(4.25)\n// .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? 41: c.pitch, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n\n// .notePlay();\n\n\n// // export var melody3 = rootMelody\n// // .metro(0.5)\n// // // .duration((n) => n.duration / 2)\n// // .bjorklund(8,3,1)\n// //  .swing(0.25,swingAmount)\n// // .pitch((n) => n.pitch-7)\n// // // .delay(4.25)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 3: c.pitch+4, velocity:sameTime ? c.velocity*0.8: c.velocity+0, duration: sameTime ? c.duration*4: c.duration*3}\n// // }, melody)\n// // .map((n) => [{pitch: n.pitch+3, time:n.time\n// // //+Math.random()*0.4-0.2\n// // }, {pitch: n.pitch}])\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-transpose])\n// // .velocity([0.5,0.7,0.5,0.3])\n\n// // .notePlay();\n\n\n// // export var pitchb3 = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .duration((n) => n.duration*0.9) \n// // .eventCount()\n// // .prop(\"pitchBend\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     //var timePassed2=1-(Math.abs(timePassed -0.5)*2);\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // })\n\n// //  .velocity(0.7)\n// // //  .pitch(60)\n\n// // // .pitch((n) => scaleArray[n.pitch.valueOf()-9])\n// // .notePlay()\n// // .automatePlay(\"pitchBend\")\n// // ;\n\n\n// // export var pitchb_concept_test = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .eventCount()\n// // .notePlay()\n// // .merge()\n// // .set(\"pitchBend\", (n) => m.evt({type:\"automation\"}).metro(1/128).set({value:}))\n// // .automatePlay(\"pitchBend_old\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // }).automatePlay(\"pitchBend\", );\n\n// // //console.log(\"PITCHBEND\",pitchbend.take(10).toArray());\n\n      "
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = (notes, note) => ({pitch: notesotes[(note.pitch-60+(notes.length*1000))%chordNotes.length]*Math.floor((note.pitch-60)/notes.length)});\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch:n[1], duration:1, time:n[0]}))).velocity(0.8).loopLength(8);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = (notes, note) => ({pitch: notesotes[(note.pitch-60+(notes.length*1000))%chordNotes.length]*Math.floor((note.pitch-60)/notes.length)});\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch:mapNote(scaleNotes,n[1]), duration:1, time:n[0]}))).velocity(0.8).loopLength(8);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = (notes, note) => ({pitch: notesotes[(note.pitch-60+(notes.length*1000))%chordNotes.length]*Math.floor((note.pitch-60)/notes.length)});\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: mapNote(scaleNotes,n[1]), duration:1, time:n[0]}))).velocity(0.8).loopLength(8);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = (notes, note) => ({pitch: notes[(note.pitch-60+(notes.length*1000))%chordNotes.length]*Math.floor((note.pitch-60)/notes.length)});\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: mapNote(scaleNotes,n[1]), duration:1, time:n[0]}))).velocity(0.8).loopLength(8);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = (notes, note) => ({pitch: notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length)});\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: mapNote(scaleNotes,n[1]), duration:1, time:n[0]}))).velocity(0.8).loopLength(8);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = (notes, note) => ({pitch: notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length)});\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: mapNote(scaleNotes,n[1]), duration:1, time:n[0]}))).velocity(0.8).loopLength(8);\nconsole.log(\"melody\",melody);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => ({pitch: notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length)}));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melody\",melody);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
1	"\n\n\n\nexport var kick=m.evt({pitch:60, velocity:0.9, duration:0.5}).metro(0.25).bjorklund(16,9,1);//.notePlay();\n\n\n\n   \n// // import {Yegros_Transformed} from \"./externalSeq\";\n import {progression,bassprog,Yegros_Transformed,cesaria,ostinato} from \"./abletonClip\";\n\n\nexport var tst = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);\n// // console.log(Yegros_Transformed.take(50).toArray());\n\n// // throw \"bye\";\n\n// export var kick=m.evt({pitch:40, velocity:0.9, duration:0.5}).metro(1).notePlay();\n\n//export var failMe=m.data([{pitch:60, velocity:0.9, duration:5, time:0},{pitch:60, velocity:0.9, duration:1, time:2}]).notePlay().cache();\n\n// export var cowbell = m.evt({pitch:60, velocity: [0.8,0.5,0.3], duration:0.1})\n// .metro(0.25)\n\n// .bjorklund(16,9,0)\n// .swing(0.25, 0.05);\n\n\n\n\n\n\n// export var kick2=m.evt({pitch:60, velocity:0.9, duration:7}).metro(8).automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);//.notePlay().cache();\n\n\nexport var kick3=m.evt({pitch:[47,45], velocity:0.9, duration:0.2, color:[\"white\",\"orange\",\"red\"]}).metro(2/3).bjorklund(16,16,0);//.notePlay().cache();\n\nexport var kickMerged = kick3.merge(kick.pitch((n)=>n.pitch+12));    \n// export var kick4 = kick3.metro(0.5).merge(kick)\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25).delay(1);//.notePlay().cache();\n\n// export var kick5 = kick4.pitch(n => n.pitch -12);//.notePlay();\n\nexport var hat = m.evt({pitch:30, duration:0.2,velocity:[0.5,0.7,0.8]}).metro(0.25).bjorklund(16,6,0)\n.automate(\"param1\", (n) => {\n var period =2.5;\n     var easingFunc = easer().using(\"in-expo\");\n     var x = ((n.evt.time) % (period))/(period);\n    var prop = x;// easingFunc(x);\n return prop;\n})\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25)\n\n//  .swing(0.25,0.1)\n\n// .bjorklund(8,5,2)\n// .automate(\"param1\", (n) => {\n//  var period =2.5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param2\", (n) => {\n//  var period =4;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;//easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param3\", (n) => {\n//  var period = 5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// }); \n\n// .notePlay().cache();\n\n\nexport var hat3 = m.evt({pitch:60, duration:0.2,velocity:[0.5,0.7,0.8,0.6]}).metro(0.25).combineMap((c) => {\n    var sameTime = c.other.next && c.other.next.time == c.time;\n    var res=[{duration:0.1, velocity:  sameTime ? 0.4 : c.velocity, time:c.time, pitch: sameTime?c.pitch+12:c.pitch}];\n    var res2={duration:0.1, velocity:  0.5, time:c.time+0.25, pitch:c.pitch+12};\n    //console.log(\"REES\",res);\n    if (sameTime)\n        res.push(res2);\n    return res;\n},kick3)\n.swing(0.5,0.2)\n// .quantize(0.5,1)\n .delay(0.5)\n.durationsFromTime()\n.automate(\"param1\", (n) => {\n console.log(\"p1\",n);\n return easer().using(\"out-cubic\")(1-((n.time+n.evt.time) % (4))/(4));\n});\nconsole.log(\"tomtomtomtom\");\n\n//.notePlay().cache();\n\n\n\n// var getScale = (noteCount, offset) => m.count(0,1).bjorklund(12,noteCount,offset).takeWhile((n) => n<127);\n\n// var inScale = (scale, pitches) => _.intersection(scale, _.uniq(pitches)).length == _.uniq(pitches).length;\n\n\n// var transpose = -0;\n// var scaleNoteCount = 7;\n// var scaleOffset =0;\n\n// var melodyTranspose = 0;\n// // find scale\n\n//  var pitches = [61,66,57,64,56,61,61,63,64,64,56,61];\n// //var pitches = [53,69,65,61,50,57];\n// var melodyPitches = m.data(pitches);\n\n// var foundScale;\n\n//  console.log(\"PITCHES IN MELODY\",_.uniq(melodyPitches.toArray()));\n\n// for (scaleOffset=0; scaleOffset<12; scaleOffset++) {\n//     foundScale = getScale(scaleNoteCount, scaleOffset);\n//     if (inScale(foundScale.toArray(), pitches)) {\n//         console.log(\"fooound scale \"+foundScale);   \n//         break;\n//     }\n// }\n\n\n\n// var scale = foundScale;\n// var scaleArray = scale.toArray();\n// console.log(\"scaleArray \"+scale.toArray());\n\n\n\n\n// // // .map((n) => n+3)\n\n// var pitchesInScale = melodyPitches.map((n) => Math.floor(n*scaleNoteCount/12)).take(pitches.length);\n// //melodyPitches = melodyPitches.map((n) => scaleArray[Math.floor(n*scaleNoteCount/12)])\n\n// // // ;\n\n// var swingAmount = 0.1;\n// // var test1 = m.evt([{pitch:12},{pitch:13}]);\n\n// //  for (let p of melodyPitches.take(15))\n// //      console.log(\"melodyPitch\",p*scaleNoteCount/12);\n\n// var rootMelody = m.evt({pitch:pitchesInScale, duration:[1,0.5,0.5,1,0.5,0.5], velocity:[0.3,0.2,0.2,0.35]});\n\n// export var melody = rootMelody\n// .metro(1/4).duration((n) => n.duration / 2.1)\n// .bjorklund(16,9,2)\n//  .swing(0.25,swingAmount)\n// .pitch((n) => n.pitch+4+transpose)\n// .pitch((n) => scaleArray[n.pitch.valueOf()])\n// .notePlay();\n\n\n// // export var amelody = rootMelody\n\n// // .metro(4)\n\n// // .bjorklund(16,9,2)\n// // .durationsFromTime()\n// // // .swing(0.25,swingAmount)\n\n\n// //  //.map((n) => console.log(\"map\",n))\n// //  //.automate(\"pitchBend\")\n// // // .pitch((n) => n.pitch+4+transpose)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-2])\n// //  .withNext()\n \n \n// //  .map((n) => m.data(n.me).prop(\"nextTime\",n.next.time).take(1))\n\n// // console.log(\"AAAA\",amelody.take(5).toArray());\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n.combine(node.groupByTime().eventCount())\n//  .withNext()\n//  .map((n) => m.data(n.me).take(1))\n .automate(\"pitchBend\",(n) => {\n  //   console.log(\"PEEBEE\",n);\n    //  return 0.5;\n    if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n    }\n    var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n    var evtNo2 = Math.floor(n.evt.other.next.count/16);\n    var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n    var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n    var nextPitch = next.pitch.valueOf();\n    var prevPitch = prev.pitch.valueOf();\n    var mePitch=n.evt.pitch.valueOf();\n    //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n    var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n    \n  // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n    var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n    if (meLastDelta >6)\n      meLastDelta -=12;\n    // pitchNow=(96+pitchNow)%24-12;\n    // console.log((mePitch%24 - pitchNow)/24);   \n    var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n    if (meNextDelta >6)\n      meNextDelta -=12;\n    //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n   \n    var amplitude = 1;\n    var x= n.time/n.duration;\n    var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n    var easingFunc = easer().using(\"in-expo\");\n    var prop =easingFunc(xTransformed);\n  // prop = 0;\n    var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n //   console.log(\"res\",0.5 + nowDelta/12)\n    return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n }\n ).prop(\"pitchBend\", (n) => n.pitchBend );\n var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n .notePlay().merge(pbAuto.delay(delay));\n return res;\n};\n\nexport var melPBPlayer = pitchBendPlayer(ostinato,0,52,0.3,0,32).pitch((n) => n.pitch+12);\nexport var melPBPlayer2 = pitchBendPlayer(ostinato,1,52,0.5,0,32);\nexport var melPBPlayer3 = pitchBendPlayer(ostinato,0,52,0.4,0,32);\n//export var melPBPlayer3 = pitchBendPlayer(progression,3,50,0,0.5);\nexport var deeperPBPlayer = pitchBendPlayer(ostinato,0,62,0,0,1/6);\nexport var deeperPBPlayer2 = pitchBendPlayer(ostinato,0,54,0,0,1.5);\n//console.log(melPBPlayer.take(5).toArray());\n\n// // throw \"hi\";\n// // export var melody2 = rootMelody\n// // .metro(1/4)\n// // .duration((n) => n.duration / 2)\n// // .bjorklund(16,13,2)\n// //  .swing(0.25,swingAmount)\n\n// // // .delay(4.25)\n// // .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 7+transpose: c.pitch+11-transpose, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()])\n// // .notePlay();\n\n\n// export var melody4 = rootMelody\n// .metro(1)\n// .duration((n) => n.duration)\n// //.delay([0,0.5,1,2,3,4])\n\n \n\n//  .withNext()\n \n \n//  .map((n) => m.data(n.me).set({nextTime:n.next.time, nextPitch:n.next.pitch, myPitch:n.me.pitch, myTime: n.me.time}).take(1))\n//  .automate(\"pitchBend\",(n) => {\n\n//      //Math.min(n.nextTime-n.time,1));\n//     // console.log(\"hey\",n);\n//     var timeToNext = n.evt.nextTime - n.time- n.evt.myTime;\n//     // console.log(\"ttn\",timeToNext);\n//      if (timeToNext < 64) {\n//          var pitchNext = n.evt.nextPitch;\n//           var myPitch = n.evt.myPitch;\n//           var speed = 2;\n//           var totalDistance = (pitchNext-myPitch)/12*4/speed;\n//         //   var proportionTraveled = 1-timeToNext/32;\n//         //   console.log(\"proportionTraveled\", proportionTraveled);\n//           //console.log(Math.random()*proportionTraveled);\n//           var dist = n.evt.nextTime - n.evt.myTime;\n//          var propTraveled = 1-timeToNext/dist; \n//         //  if (propTraveled < 0.5 && propTraveled > -0.1)\n//         //     return (propTraveled/0.5)/40+0.5;\n//          var pb = Math.max(0,(propTraveled-1/speed))*totalDistance/2+0.5;\n//         //   console.log(\"propTraveled\",propTraveled,totalDistance,pb);\n          \n//          return pb;// * proportionTraveled;\n         \n//      }\n//      return 0.5;//Math.min(1,((timeToNext)%4/4));//Math.min(n.nextTime-n.time,1) \n// })\n// .pitch((n) => scaleArray[n.pitch.valueOf()+transpose])\n// .map((t) => [{time:t.time}, {time:t.time+1}, {time:t.time+1.5} , {time:t.time+2}, {time:t.time+2.5}, {time:t.time+3},{time:t.time+4}, {time:t.time+3.5} ])\n// .bjorklund(16,13,0)\n\n//  .swing(0.25,swingAmount)\n\n// // .delay(4.25)\n// .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? 41: c.pitch, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n\n// .notePlay();\n\n\n// // export var melody3 = rootMelody\n// // .metro(0.5)\n// // // .duration((n) => n.duration / 2)\n// // .bjorklund(8,3,1)\n// //  .swing(0.25,swingAmount)\n// // .pitch((n) => n.pitch-7)\n// // // .delay(4.25)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 3: c.pitch+4, velocity:sameTime ? c.velocity*0.8: c.velocity+0, duration: sameTime ? c.duration*4: c.duration*3}\n// // }, melody)\n// // .map((n) => [{pitch: n.pitch+3, time:n.time\n// // //+Math.random()*0.4-0.2\n// // }, {pitch: n.pitch}])\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-transpose])\n// // .velocity([0.5,0.7,0.5,0.3])\n\n// // .notePlay();\n\n\n// // export var pitchb3 = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .duration((n) => n.duration*0.9) \n// // .eventCount()\n// // .prop(\"pitchBend\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     //var timePassed2=1-(Math.abs(timePassed -0.5)*2);\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // })\n\n// //  .velocity(0.7)\n// // //  .pitch(60)\n\n// // // .pitch((n) => scaleArray[n.pitch.valueOf()-9])\n// // .notePlay()\n// // .automatePlay(\"pitchBend\")\n// // ;\n\n\n// // export var pitchb_concept_test = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .eventCount()\n// // .notePlay()\n// // .merge()\n// // .set(\"pitchBend\", (n) => m.evt({type:\"automation\"}).metro(1/128).set({value:}))\n// // .automatePlay(\"pitchBend_old\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // }).automatePlay(\"pitchBend\", );\n\n// // //console.log(\"PITCHBEND\",pitchbend.take(10).toArray());\n\n      "
1	"\n\n\n\nexport var kick=m.evt({pitch:60, velocity:0.9, duration:0.5}).metro(0.25).bjorklund(16,9,1);//.notePlay();\n\n\n\n   \n// // import {Yegros_Transformed} from \"./externalSeq\";\n import {progression,bassprog,Yegros_Transformed,cesaria,ostinato} from \"./abletonClip\";\n\n\nexport var tst = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);\n// // console.log(Yegros_Transformed.take(50).toArray());\n\n// // throw \"bye\";\n\n// export var kick=m.evt({pitch:40, velocity:0.9, duration:0.5}).metro(1).notePlay();\n\n//export var failMe=m.data([{pitch:60, velocity:0.9, duration:5, time:0},{pitch:60, velocity:0.9, duration:1, time:2}]).notePlay().cache();\n\n// export var cowbell = m.evt({pitch:60, velocity: [0.8,0.5,0.3], duration:0.1})\n// .metro(0.25)\n\n// .bjorklund(16,9,0)\n// .swing(0.25, 0.05);\n\n\n\n\n\n\n// export var kick2=m.evt({pitch:60, velocity:0.9, duration:7}).metro(8).automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);//.notePlay().cache();\n\n\nexport var kick3=m.evt({pitch:[47,45], velocity:0.9, duration:0.2, color:[\"white\",\"orange\",\"red\"]}).metro(2/3).bjorklund(16,16,0);//.notePlay().cache();\n\nexport var kickMerged = kick3.merge(kick.pitch((n)=>n.pitch+12));    \n// export var kick4 = kick3.metro(0.5).merge(kick)\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25).delay(1);//.notePlay().cache();\n\n// export var kick5 = kick4.pitch(n => n.pitch -12);//.notePlay();\n\nexport var hat = m.evt({pitch:30, duration:0.2,velocity:[0.5,0.7,0.8]}).metro(0.25).bjorklund(16,6,0)\n.automate(\"param1\", (n) => {\n var period =2.5;\n     var easingFunc = easer().using(\"in-expo\");\n     var x = ((n.evt.time) % (period))/(period);\n    var prop = x;// easingFunc(x);\n return prop;\n})\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25)\n\n//  .swing(0.25,0.1)\n\n// .bjorklund(8,5,2)\n// .automate(\"param1\", (n) => {\n//  var period =2.5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param2\", (n) => {\n//  var period =4;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;//easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param3\", (n) => {\n//  var period = 5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// }); \n\n// .notePlay().cache();\n\n\nexport var hat3 = m.evt({pitch:60, duration:0.2,velocity:[0.5,0.7,0.8,0.6]}).metro(0.25).combineMap((c) => {\n    var sameTime = c.other.next && c.other.next.time == c.time;\n    var res=[{duration:0.1, velocity:  sameTime ? 0.4 : c.velocity, time:c.time, pitch: sameTime?c.pitch+12:c.pitch}];\n    var res2={duration:0.1, velocity:  0.5, time:c.time+0.25, pitch:c.pitch+12};\n    //console.log(\"REES\",res);\n    if (sameTime)\n        res.push(res2);\n    return res;\n},kick3)\n.swing(0.5,0.2)\n// .quantize(0.5,1)\n .delay(0.5)\n.durationsFromTime()\n.automate(\"param1\", (n) => {\n console.log(\"p1\",n);\n return easer().using(\"out-cubic\")(1-((n.time+n.evt.time) % (4))/(4));\n});\nconsole.log(\"tomtomtomtom\");\n\n//.notePlay().cache();\n\n\n\n// var getScale = (noteCount, offset) => m.count(0,1).bjorklund(12,noteCount,offset).takeWhile((n) => n<127);\n\n// var inScale = (scale, pitches) => _.intersection(scale, _.uniq(pitches)).length == _.uniq(pitches).length;\n\n\n// var transpose = -0;\n// var scaleNoteCount = 7;\n// var scaleOffset =0;\n\n// var melodyTranspose = 0;\n// // find scale\n\n//  var pitches = [61,66,57,64,56,61,61,63,64,64,56,61];\n// //var pitches = [53,69,65,61,50,57];\n// var melodyPitches = m.data(pitches);\n\n// var foundScale;\n\n//  console.log(\"PITCHES IN MELODY\",_.uniq(melodyPitches.toArray()));\n\n// for (scaleOffset=0; scaleOffset<12; scaleOffset++) {\n//     foundScale = getScale(scaleNoteCount, scaleOffset);\n//     if (inScale(foundScale.toArray(), pitches)) {\n//         console.log(\"fooound scale \"+foundScale);   \n//         break;\n//     }\n// }\n\n\n\n// var scale = foundScale;\n// var scaleArray = scale.toArray();\n// console.log(\"scaleArray \"+scale.toArray());\n\n\n\n\n// // // .map((n) => n+3)\n\n// var pitchesInScale = melodyPitches.map((n) => Math.floor(n*scaleNoteCount/12)).take(pitches.length);\n// //melodyPitches = melodyPitches.map((n) => scaleArray[Math.floor(n*scaleNoteCount/12)])\n\n// // // ;\n\n// var swingAmount = 0.1;\n// // var test1 = m.evt([{pitch:12},{pitch:13}]);\n\n// //  for (let p of melodyPitches.take(15))\n// //      console.log(\"melodyPitch\",p*scaleNoteCount/12);\n\n// var rootMelody = m.evt({pitch:pitchesInScale, duration:[1,0.5,0.5,1,0.5,0.5], velocity:[0.3,0.2,0.2,0.35]});\n\n// export var melody = rootMelody\n// .metro(1/4).duration((n) => n.duration / 2.1)\n// .bjorklund(16,9,2)\n//  .swing(0.25,swingAmount)\n// .pitch((n) => n.pitch+4+transpose)\n// .pitch((n) => scaleArray[n.pitch.valueOf()])\n// .notePlay();\n\n\n// // export var amelody = rootMelody\n\n// // .metro(4)\n\n// // .bjorklund(16,9,2)\n// // .durationsFromTime()\n// // // .swing(0.25,swingAmount)\n\n\n// //  //.map((n) => console.log(\"map\",n))\n// //  //.automate(\"pitchBend\")\n// // // .pitch((n) => n.pitch+4+transpose)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-2])\n// //  .withNext()\n \n \n// //  .map((n) => m.data(n.me).prop(\"nextTime\",n.next.time).take(1))\n\n// // console.log(\"AAAA\",amelody.take(5).toArray());\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n.combine(node.groupByTime().eventCount())\n//  .withNext()\n//  .map((n) => m.data(n.me).take(1))\n .automate(\"pitchBend\",(n) => {\n  //   console.log(\"PEEBEE\",n);\n    //  return 0.5;\n    if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n    }\n    var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n    var evtNo2 = Math.floor(n.evt.other.next.count/16);\n    var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n    var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n    var nextPitch = next.pitch.valueOf();\n    var prevPitch = prev.pitch.valueOf();\n    var mePitch=n.evt.pitch.valueOf();\n    //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n    var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n    \n  // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n    var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n    if (meLastDelta >6)\n      meLastDelta -=12;\n    // pitchNow=(96+pitchNow)%24-12;\n    // console.log((mePitch%24 - pitchNow)/24);   \n    var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n    if (meNextDelta >6)\n      meNextDelta -=12;\n    //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n   \n    var amplitude = 1;\n    var x= n.time/n.duration;\n    var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n    var easingFunc = easer().using(\"in-expo\");\n    var prop =easingFunc(xTransformed);\n  // prop = 0;\n    var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n //   console.log(\"res\",0.5 + nowDelta/12)\n    return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n }\n ).prop(\"pitchBend\", (n) => n.pitchBend );\n var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n .notePlay().merge(pbAuto.delay(delay));\n return res;\n};\n\nexport var melPBPlayer = pitchBendPlayer(ostinato,0,52,0.3,0,32).pitch((n) => n.pitch+12);\nexport var melPBPlayer2 = pitchBendPlayer(ostinato,1,52,0.5,0,32);\nexport var melPBPlayer3 = pitchBendPlayer(ostinato,0,52,0.4,0,32);\n//export var melPBPlayer3 = pitchBendPlayer(progression,3,50,0,0.5);\nexport var deeperPBPlayer = pitchBendPlayer(ostinato,0,62,0,0,1/6);\nexport var deeperPBPlayer2 = pitchBendPlayer(ostinato,0,54,0,0,1.5);\n//console.log(melPBPlayer.take(5).toArray());\n\n// // throw \"hi\";\n// // export var melody2 = rootMelody\n// // .metro(1/4)\n// // .duration((n) => n.duration / 2)\n// // .bjorklund(16,13,2)\n// //  .swing(0.25,swingAmount)\n\n// // // .delay(4.25)\n// // .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 7+transpose: c.pitch+11-transpose, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()])\n// // .notePlay();\n\n\n// export var melody4 = rootMelody\n// .metro(1)\n// .duration((n) => n.duration)\n// //.delay([0,0.5,1,2,3,4])\n\n \n\n//  .withNext()\n \n \n//  .map((n) => m.data(n.me).set({nextTime:n.next.time, nextPitch:n.next.pitch, myPitch:n.me.pitch, myTime: n.me.time}).take(1))\n//  .automate(\"pitchBend\",(n) => {\n\n//      //Math.min(n.nextTime-n.time,1));\n//     // console.log(\"hey\",n);\n//     var timeToNext = n.evt.nextTime - n.time- n.evt.myTime;\n//     // console.log(\"ttn\",timeToNext);\n//      if (timeToNext < 64) {\n//          var pitchNext = n.evt.nextPitch;\n//           var myPitch = n.evt.myPitch;\n//           var speed = 2;\n//           var totalDistance = (pitchNext-myPitch)/12*4/speed;\n//         //   var proportionTraveled = 1-timeToNext/32;\n//         //   console.log(\"proportionTraveled\", proportionTraveled);\n//           //console.log(Math.random()*proportionTraveled);\n//           var dist = n.evt.nextTime - n.evt.myTime;\n//          var propTraveled = 1-timeToNext/dist; \n//         //  if (propTraveled < 0.5 && propTraveled > -0.1)\n//         //     return (propTraveled/0.5)/40+0.5;\n//          var pb = Math.max(0,(propTraveled-1/speed))*totalDistance/2+0.5;\n//         //   console.log(\"propTraveled\",propTraveled,totalDistance,pb);\n          \n//          return pb;// * proportionTraveled;\n         \n//      }\n//      return 0.5;//Math.min(1,((timeToNext)%4/4));//Math.min(n.nextTime-n.time,1) \n// })\n// .pitch((n) => scaleArray[n.pitch.valueOf()+transpose])\n// .map((t) => [{time:t.time}, {time:t.time+1}, {time:t.time+1.5} , {time:t.time+2}, {time:t.time+2.5}, {time:t.time+3},{time:t.time+4}, {time:t.time+3.5} ])\n// .bjorklund(16,13,0)\n\n//  .swing(0.25,swingAmount)\n\n// // .delay(4.25)\n// .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? 41: c.pitch, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n\n// .notePlay();\n\n\n// // export var melody3 = rootMelody\n// // .metro(0.5)\n// // // .duration((n) => n.duration / 2)\n// // .bjorklund(8,3,1)\n// //  .swing(0.25,swingAmount)\n// // .pitch((n) => n.pitch-7)\n// // // .delay(4.25)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 3: c.pitch+4, velocity:sameTime ? c.velocity*0.8: c.velocity+0, duration: sameTime ? c.duration*4: c.duration*3}\n// // }, melody)\n// // .map((n) => [{pitch: n.pitch+3, time:n.time\n// // //+Math.random()*0.4-0.2\n// // }, {pitch: n.pitch}])\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-transpose])\n// // .velocity([0.5,0.7,0.5,0.3])\n\n// // .notePlay();\n\n\n// // export var pitchb3 = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .duration((n) => n.duration*0.9) \n// // .eventCount()\n// // .prop(\"pitchBend\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     //var timePassed2=1-(Math.abs(timePassed -0.5)*2);\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // })\n\n// //  .velocity(0.7)\n// // //  .pitch(60)\n\n// // // .pitch((n) => scaleArray[n.pitch.valueOf()-9])\n// // .notePlay()\n// // .automatePlay(\"pitchBend\")\n// // ;\n\n\n// // export var pitchb_concept_test = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .eventCount()\n// // .notePlay()\n// // .merge()\n// // .set(\"pitchBend\", (n) => m.evt({type:\"automation\"}).metro(1/128).set({value:}))\n// // .automatePlay(\"pitchBend_old\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // }).automatePlay(\"pitchBend\", );\n\n// // //console.log(\"PITCHBEND\",pitchbend.take(10).toArray());\n\n      "
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => ({pitch: notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length)}));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melody\",melody);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => ({pitch: notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length)}));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melody\",melody);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => ({pitch: notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length)}));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .map(toScale)\n    .loopLength(8);\nconsole.log(\"melody\",melody);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
1	"\n\n\n\nexport var kick=m.evt({pitch:60, velocity:0.9, duration:0.5}).metro(0.25).bjorklund(16,9,1);//.notePlay();\n\n\n\n   \n// // import {Yegros_Transformed} from \"./externalSeq\";\n import {progression,bassprog,Yegros_Transformed,cesaria,ostinato} from \"./abletonClip\";\n\n\nexport var tst = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);\n// // console.log(Yegros_Transformed.take(50).toArray());\n\n// // throw \"bye\";\n\n// export var kick=m.evt({pitch:40, velocity:0.9, duration:0.5}).metro(1).notePlay();\n\n//export var failMe=m.data([{pitch:60, velocity:0.9, duration:5, time:0},{pitch:60, velocity:0.9, duration:1, time:2}]).notePlay().cache();\n\n// export var cowbell = m.evt({pitch:60, velocity: [0.8,0.5,0.3], duration:0.1})\n// .metro(0.25)\n\n// .bjorklund(16,9,0)\n// .swing(0.25, 0.05);\n\n\n\n\n\n\n// export var kick2=m.evt({pitch:60, velocity:0.9, duration:7}).metro(8).automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);//.notePlay().cache();\n\n\nexport var kick3=m.evt({pitch:[47,45], velocity:0.9, duration:0.2, color:[\"white\",\"orange\",\"red\"]}).metro(2/3).bjorklund(16,16,0);//.notePlay().cache();\n\nexport var kickMerged = kick3.merge(kick.pitch((n)=>n.pitch+12));    \n// export var kick4 = kick3.metro(0.5).merge(kick)\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25).delay(1);//.notePlay().cache();\n\n// export var kick5 = kick4.pitch(n => n.pitch -12);//.notePlay();\n\nexport var hat = m.evt({pitch:30, duration:0.2,velocity:[0.5,0.7,0.8]}).metro(0.25).bjorklund(16,6,0)\n.automate(\"param1\", (n) => {\n var period =2.5;\n     var easingFunc = easer().using(\"in-expo\");\n     var x = ((n.evt.time) % (period))/(period);\n    var prop = x;// easingFunc(x);\n return prop;\n})\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25)\n\n//  .swing(0.25,0.1)\n\n// .bjorklund(8,5,2)\n// .automate(\"param1\", (n) => {\n//  var period =2.5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param2\", (n) => {\n//  var period =4;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;//easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param3\", (n) => {\n//  var period = 5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// }); \n\n// .notePlay().cache();\n\n\nexport var hat3 = m.evt({pitch:60, duration:0.2,velocity:[0.5,0.7,0.8,0.6]}).metro(0.25).combineMap((c) => {\n    var sameTime = c.other.next && c.other.next.time == c.time;\n    var res=[{duration:0.1, velocity:  sameTime ? 0.4 : c.velocity, time:c.time, pitch: sameTime?c.pitch+12:c.pitch}];\n    var res2={duration:0.1, velocity:  0.5, time:c.time+0.25, pitch:c.pitch+12};\n    //console.log(\"REES\",res);\n    if (sameTime)\n        res.push(res2);\n    return res;\n},kick3)\n.swing(0.5,0.2)\n// .quantize(0.5,1)\n .delay(0.5)\n.durationsFromTime()\n.automate(\"param1\", (n) => {\n console.log(\"p1\",n);\n return easer().using(\"out-cubic\")(1-((n.time+n.evt.time) % (4))/(4));\n});\nconsole.log(\"tomtomtomtom\");\n\n//.notePlay().cache();\n\n\n\n// var getScale = (noteCount, offset) => m.count(0,1).bjorklund(12,noteCount,offset).takeWhile((n) => n<127);\n\n// var inScale = (scale, pitches) => _.intersection(scale, _.uniq(pitches)).length == _.uniq(pitches).length;\n\n\n// var transpose = -0;\n// var scaleNoteCount = 7;\n// var scaleOffset =0;\n\n// var melodyTranspose = 0;\n// // find scale\n\n//  var pitches = [61,66,57,64,56,61,61,63,64,64,56,61];\n// //var pitches = [53,69,65,61,50,57];\n// var melodyPitches = m.data(pitches);\n\n// var foundScale;\n\n//  console.log(\"PITCHES IN MELODY\",_.uniq(melodyPitches.toArray()));\n\n// for (scaleOffset=0; scaleOffset<12; scaleOffset++) {\n//     foundScale = getScale(scaleNoteCount, scaleOffset);\n//     if (inScale(foundScale.toArray(), pitches)) {\n//         console.log(\"fooound scale \"+foundScale);   \n//         break;\n//     }\n// }\n\n\n\n// var scale = foundScale;\n// var scaleArray = scale.toArray();\n// console.log(\"scaleArray \"+scale.toArray());\n\n\n\n\n// // // .map((n) => n+3)\n\n// var pitchesInScale = melodyPitches.map((n) => Math.floor(n*scaleNoteCount/12)).take(pitches.length);\n// //melodyPitches = melodyPitches.map((n) => scaleArray[Math.floor(n*scaleNoteCount/12)])\n\n// // // ;\n\n// var swingAmount = 0.1;\n// // var test1 = m.evt([{pitch:12},{pitch:13}]);\n\n// //  for (let p of melodyPitches.take(15))\n// //      console.log(\"melodyPitch\",p*scaleNoteCount/12);\n\n// var rootMelody = m.evt({pitch:pitchesInScale, duration:[1,0.5,0.5,1,0.5,0.5], velocity:[0.3,0.2,0.2,0.35]});\n\n// export var melody = rootMelody\n// .metro(1/4).duration((n) => n.duration / 2.1)\n// .bjorklund(16,9,2)\n//  .swing(0.25,swingAmount)\n// .pitch((n) => n.pitch+4+transpose)\n// .pitch((n) => scaleArray[n.pitch.valueOf()])\n// .notePlay();\n\n\n// // export var amelody = rootMelody\n\n// // .metro(4)\n\n// // .bjorklund(16,9,2)\n// // .durationsFromTime()\n// // // .swing(0.25,swingAmount)\n\n\n// //  //.map((n) => console.log(\"map\",n))\n// //  //.automate(\"pitchBend\")\n// // // .pitch((n) => n.pitch+4+transpose)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-2])\n// //  .withNext()\n \n \n// //  .map((n) => m.data(n.me).prop(\"nextTime\",n.next.time).take(1))\n\n// // console.log(\"AAAA\",amelody.take(5).toArray());\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n.combine(node.groupByTime().eventCount())\n//  .withNext()\n//  .map((n) => m.data(n.me).take(1))\n .automate(\"pitchBend\",(n) => {\n  //   console.log(\"PEEBEE\",n);\n    //  return 0.5;\n    if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n    }\n    var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n    var evtNo2 = Math.floor(n.evt.other.next.count/16);\n    var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n    var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n    var nextPitch = next.pitch.valueOf();\n    var prevPitch = prev.pitch.valueOf();\n    var mePitch=n.evt.pitch.valueOf();\n    //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n    var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n    \n  // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n    var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n    if (meLastDelta >6)\n      meLastDelta -=12;\n    // pitchNow=(96+pitchNow)%24-12;\n    // console.log((mePitch%24 - pitchNow)/24);   \n    var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n    if (meNextDelta >6)\n      meNextDelta -=12;\n    //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n   \n    var amplitude = 1;\n    var x= n.time/n.duration;\n    var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n    var easingFunc = easer().using(\"in-expo\");\n    var prop =easingFunc(xTransformed);\n  // prop = 0;\n    var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n //   console.log(\"res\",0.5 + nowDelta/12)\n    return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n }\n ).prop(\"pitchBend\", (n) => n.pitchBend );\n var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n .notePlay().merge(pbAuto.delay(delay));\n return res;\n};\n\nexport var melPBPlayer = pitchBendPlayer(ostinato,0,52,0.3,0,32).pitch((n) => n.pitch+12);\nexport var melPBPlayer2 = pitchBendPlayer(ostinato,1,52,0.5,0,32);\nexport var melPBPlayer3 = pitchBendPlayer(ostinato,0,52,0.4,0,32);\n//export var melPBPlayer3 = pitchBendPlayer(progression,3,50,0,0.5);\nexport var deeperPBPlayer = pitchBendPlayer(ostinato,0,62,0,0,1/6);\nexport var deeperPBPlayer2 = pitchBendPlayer(ostinato,0,54,0,0,1.5);\n//console.log(melPBPlayer.take(5).toArray());\n\n// // throw \"hi\";\n// // export var melody2 = rootMelody\n// // .metro(1/4)\n// // .duration((n) => n.duration / 2)\n// // .bjorklund(16,13,2)\n// //  .swing(0.25,swingAmount)\n\n// // // .delay(4.25)\n// // .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 7+transpose: c.pitch+11-transpose, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()])\n// // .notePlay();\n\n\n// export var melody4 = rootMelody\n// .metro(1)\n// .duration((n) => n.duration)\n// //.delay([0,0.5,1,2,3,4])\n\n \n\n//  .withNext()\n \n \n//  .map((n) => m.data(n.me).set({nextTime:n.next.time, nextPitch:n.next.pitch, myPitch:n.me.pitch, myTime: n.me.time}).take(1))\n//  .automate(\"pitchBend\",(n) => {\n\n//      //Math.min(n.nextTime-n.time,1));\n//     // console.log(\"hey\",n);\n//     var timeToNext = n.evt.nextTime - n.time- n.evt.myTime;\n//     // console.log(\"ttn\",timeToNext);\n//      if (timeToNext < 64) {\n//          var pitchNext = n.evt.nextPitch;\n//           var myPitch = n.evt.myPitch;\n//           var speed = 2;\n//           var totalDistance = (pitchNext-myPitch)/12*4/speed;\n//         //   var proportionTraveled = 1-timeToNext/32;\n//         //   console.log(\"proportionTraveled\", proportionTraveled);\n//           //console.log(Math.random()*proportionTraveled);\n//           var dist = n.evt.nextTime - n.evt.myTime;\n//          var propTraveled = 1-timeToNext/dist; \n//         //  if (propTraveled < 0.5 && propTraveled > -0.1)\n//         //     return (propTraveled/0.5)/40+0.5;\n//          var pb = Math.max(0,(propTraveled-1/speed))*totalDistance/2+0.5;\n//         //   console.log(\"propTraveled\",propTraveled,totalDistance,pb);\n          \n//          return pb;// * proportionTraveled;\n         \n//      }\n//      return 0.5;//Math.min(1,((timeToNext)%4/4));//Math.min(n.nextTime-n.time,1) \n// })\n// .pitch((n) => scaleArray[n.pitch.valueOf()+transpose])\n// .map((t) => [{time:t.time}, {time:t.time+1}, {time:t.time+1.5} , {time:t.time+2}, {time:t.time+2.5}, {time:t.time+3},{time:t.time+4}, {time:t.time+3.5} ])\n// .bjorklund(16,13,0)\n\n//  .swing(0.25,swingAmount)\n\n// // .delay(4.25)\n// .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? 41: c.pitch, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n\n// .notePlay();\n\n\n// // export var melody3 = rootMelody\n// // .metro(0.5)\n// // // .duration((n) => n.duration / 2)\n// // .bjorklund(8,3,1)\n// //  .swing(0.25,swingAmount)\n// // .pitch((n) => n.pitch-7)\n// // // .delay(4.25)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 3: c.pitch+4, velocity:sameTime ? c.velocity*0.8: c.velocity+0, duration: sameTime ? c.duration*4: c.duration*3}\n// // }, melody)\n// // .map((n) => [{pitch: n.pitch+3, time:n.time\n// // //+Math.random()*0.4-0.2\n// // }, {pitch: n.pitch}])\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-transpose])\n// // .velocity([0.5,0.7,0.5,0.3])\n\n// // .notePlay();\n\n\n// // export var pitchb3 = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .duration((n) => n.duration*0.9) \n// // .eventCount()\n// // .prop(\"pitchBend\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     //var timePassed2=1-(Math.abs(timePassed -0.5)*2);\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // })\n\n// //  .velocity(0.7)\n// // //  .pitch(60)\n\n// // // .pitch((n) => scaleArray[n.pitch.valueOf()-9])\n// // .notePlay()\n// // .automatePlay(\"pitchBend\")\n// // ;\n\n\n// // export var pitchb_concept_test = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .eventCount()\n// // .notePlay()\n// // .merge()\n// // .set(\"pitchBend\", (n) => m.evt({type:\"automation\"}).metro(1/128).set({value:}))\n// // .automatePlay(\"pitchBend_old\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // }).automatePlay(\"pitchBend\", );\n\n// // //console.log(\"PITCHBEND\",pitchbend.take(10).toArray());\n\n      "
1	"\n\n\n\nexport var kick=m.evt({pitch:60, velocity:0.9, duration:0.5}).metro(0.25).bjorklund(16,9,1);//.notePlay();\n\n\n\n   \n// // import {Yegros_Transformed} from \"./externalSeq\";\n import {progression,bassprog,Yegros_Transformed,cesaria,ostinato} from \"./abletonClip\";\n\n\nexport var tst = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);\n// // console.log(Yegros_Transformed.take(50).toArray());\n\n// // throw \"bye\";\n\n// export var kick=m.evt({pitch:40, velocity:0.9, duration:0.5}).metro(1).notePlay();\n\n//export var failMe=m.data([{pitch:60, velocity:0.9, duration:5, time:0},{pitch:60, velocity:0.9, duration:1, time:2}]).notePlay().cache();\n\n// export var cowbell = m.evt({pitch:60, velocity: [0.8,0.5,0.3], duration:0.1})\n// .metro(0.25)\n\n// .bjorklund(16,9,0)\n// .swing(0.25, 0.05);\n\n\n\n\n\n\n// export var kick2=m.evt({pitch:60, velocity:0.9, duration:7}).metro(8).automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);//.notePlay().cache();\n\n\nexport var kick3=m.evt({pitch:[47,45], velocity:0.9, duration:0.2, color:[\"white\",\"orange\",\"red\"]}).metro(2/3).bjorklund(16,16,0);//.notePlay().cache();\n\nexport var kickMerged = kick3.merge(kick.pitch((n)=>n.pitch+12));    \n// export var kick4 = kick3.metro(0.5).merge(kick)\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25).delay(1);//.notePlay().cache();\n\n// export var kick5 = kick4.pitch(n => n.pitch -12);//.notePlay();\n\nexport var hat = m.evt({pitch:30, duration:0.2,velocity:[0.5,0.7,0.8]}).metro(0.25).bjorklund(16,6,0)\n.automate(\"param1\", (n) => {\n var period =2.5;\n     var easingFunc = easer().using(\"in-expo\");\n     var x = ((n.evt.time) % (period))/(period);\n    var prop = x;// easingFunc(x);\n return prop;\n})\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25)\n\n//  .swing(0.25,0.1)\n\n// .bjorklund(8,5,2)\n// .automate(\"param1\", (n) => {\n//  var period =2.5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param2\", (n) => {\n//  var period =4;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;//easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param3\", (n) => {\n//  var period = 5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// }); \n\n// .notePlay().cache();\n\n\nexport var hat3 = m.evt({pitch:60, duration:0.2,velocity:[0.5,0.7,0.8,0.6]}).metro(0.25).combineMap((c) => {\n    var sameTime = c.other.next && c.other.next.time == c.time;\n    var res=[{duration:0.1, velocity:  sameTime ? 0.4 : c.velocity, time:c.time, pitch: sameTime?c.pitch+12:c.pitch}];\n    var res2={duration:0.1, velocity:  0.5, time:c.time+0.25, pitch:c.pitch+12};\n    //console.log(\"REES\",res);\n    if (sameTime)\n        res.push(res2);\n    return res;\n},kick3)\n.swing(0.5,0.2)\n// .quantize(0.5,1)\n .delay(0.5)\n.durationsFromTime()\n.automate(\"param1\", (n) => {\n console.log(\"p1\",n);\n return easer().using(\"out-cubic\")(1-((n.time+n.evt.time) % (4))/(4));\n});\nconsole.log(\"tomtomtomtom\");\n\n//.notePlay().cache();\n\n\n\n// var getScale = (noteCount, offset) => m.count(0,1).bjorklund(12,noteCount,offset).takeWhile((n) => n<127);\n\n// var inScale = (scale, pitches) => _.intersection(scale, _.uniq(pitches)).length == _.uniq(pitches).length;\n\n\n// var transpose = -0;\n// var scaleNoteCount = 7;\n// var scaleOffset =0;\n\n// var melodyTranspose = 0;\n// // find scale\n\n//  var pitches = [61,66,57,64,56,61,61,63,64,64,56,61];\n// //var pitches = [53,69,65,61,50,57];\n// var melodyPitches = m.data(pitches);\n\n// var foundScale;\n\n//  console.log(\"PITCHES IN MELODY\",_.uniq(melodyPitches.toArray()));\n\n// for (scaleOffset=0; scaleOffset<12; scaleOffset++) {\n//     foundScale = getScale(scaleNoteCount, scaleOffset);\n//     if (inScale(foundScale.toArray(), pitches)) {\n//         console.log(\"fooound scale \"+foundScale);   \n//         break;\n//     }\n// }\n\n\n\n// var scale = foundScale;\n// var scaleArray = scale.toArray();\n// console.log(\"scaleArray \"+scale.toArray());\n\n\n\n\n// // // .map((n) => n+3)\n\n// var pitchesInScale = melodyPitches.map((n) => Math.floor(n*scaleNoteCount/12)).take(pitches.length);\n// //melodyPitches = melodyPitches.map((n) => scaleArray[Math.floor(n*scaleNoteCount/12)])\n\n// // // ;\n\n// var swingAmount = 0.1;\n// // var test1 = m.evt([{pitch:12},{pitch:13}]);\n\n// //  for (let p of melodyPitches.take(15))\n// //      console.log(\"melodyPitch\",p*scaleNoteCount/12);\n\n// var rootMelody = m.evt({pitch:pitchesInScale, duration:[1,0.5,0.5,1,0.5,0.5], velocity:[0.3,0.2,0.2,0.35]});\n\n// export var melody = rootMelody\n// .metro(1/4).duration((n) => n.duration / 2.1)\n// .bjorklund(16,9,2)\n//  .swing(0.25,swingAmount)\n// .pitch((n) => n.pitch+4+transpose)\n// .pitch((n) => scaleArray[n.pitch.valueOf()])\n// .notePlay();\n\n\n// // export var amelody = rootMelody\n\n// // .metro(4)\n\n// // .bjorklund(16,9,2)\n// // .durationsFromTime()\n// // // .swing(0.25,swingAmount)\n\n\n// //  //.map((n) => console.log(\"map\",n))\n// //  //.automate(\"pitchBend\")\n// // // .pitch((n) => n.pitch+4+transpose)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-2])\n// //  .withNext()\n \n \n// //  .map((n) => m.data(n.me).prop(\"nextTime\",n.next.time).take(1))\n\n// // console.log(\"AAAA\",amelody.take(5).toArray());\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n.combine(node.groupByTime().eventCount())\n//  .withNext()\n//  .map((n) => m.data(n.me).take(1))\n .automate(\"pitchBend\",(n) => {\n  //   console.log(\"PEEBEE\",n);\n    //  return 0.5;\n    if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n    }\n    var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n    var evtNo2 = Math.floor(n.evt.other.next.count/16);\n    var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n    var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n    var nextPitch = next.pitch.valueOf();\n    var prevPitch = prev.pitch.valueOf();\n    var mePitch=n.evt.pitch.valueOf();\n    //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n    var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n    \n  // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n    var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n    if (meLastDelta >6)\n      meLastDelta -=12;\n    // pitchNow=(96+pitchNow)%24-12;\n    // console.log((mePitch%24 - pitchNow)/24);   \n    var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n    if (meNextDelta >6)\n      meNextDelta -=12;\n    //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n   \n    var amplitude = 1;\n    var x= n.time/n.duration;\n    var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n    var easingFunc = easer().using(\"in-expo\");\n    var prop =easingFunc(xTransformed);\n  // prop = 0;\n    var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n //   console.log(\"res\",0.5 + nowDelta/12)\n    return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n }\n ).prop(\"pitchBend\", (n) => n.pitchBend );\n var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n .notePlay().merge(pbAuto.delay(delay));\n return res;\n};\n\nexport var melPBPlayer = pitchBendPlayer(ostinato,0,52,0.3,0,32).pitch((n) => n.pitch+12);\nexport var melPBPlayer2 = pitchBendPlayer(ostinato,1,52,0.5,0,32);\nexport var melPBPlayer3 = pitchBendPlayer(ostinato,0,52,0.4,0,32);\n//export var melPBPlayer3 = pitchBendPlayer(progression,3,50,0,0.5);\nexport var deeperPBPlayer = pitchBendPlayer(ostinato,0,62,0,0,1/6);\nexport var deeperPBPlayer2 = pitchBendPlayer(ostinato,0,54,0,0,1.5);\n//console.log(melPBPlayer.take(5).toArray());\n\n// // throw \"hi\";\n// // export var melody2 = rootMelody\n// // .metro(1/4)\n// // .duration((n) => n.duration / 2)\n// // .bjorklund(16,13,2)\n// //  .swing(0.25,swingAmount)\n\n// // // .delay(4.25)\n// // .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 7+transpose: c.pitch+11-transpose, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()])\n// // .notePlay();\n\n\n// export var melody4 = rootMelody\n// .metro(1)\n// .duration((n) => n.duration)\n// //.delay([0,0.5,1,2,3,4])\n\n \n\n//  .withNext()\n \n \n//  .map((n) => m.data(n.me).set({nextTime:n.next.time, nextPitch:n.next.pitch, myPitch:n.me.pitch, myTime: n.me.time}).take(1))\n//  .automate(\"pitchBend\",(n) => {\n\n//      //Math.min(n.nextTime-n.time,1));\n//     // console.log(\"hey\",n);\n//     var timeToNext = n.evt.nextTime - n.time- n.evt.myTime;\n//     // console.log(\"ttn\",timeToNext);\n//      if (timeToNext < 64) {\n//          var pitchNext = n.evt.nextPitch;\n//           var myPitch = n.evt.myPitch;\n//           var speed = 2;\n//           var totalDistance = (pitchNext-myPitch)/12*4/speed;\n//         //   var proportionTraveled = 1-timeToNext/32;\n//         //   console.log(\"proportionTraveled\", proportionTraveled);\n//           //console.log(Math.random()*proportionTraveled);\n//           var dist = n.evt.nextTime - n.evt.myTime;\n//          var propTraveled = 1-timeToNext/dist; \n//         //  if (propTraveled < 0.5 && propTraveled > -0.1)\n//         //     return (propTraveled/0.5)/40+0.5;\n//          var pb = Math.max(0,(propTraveled-1/speed))*totalDistance/2+0.5;\n//         //   console.log(\"propTraveled\",propTraveled,totalDistance,pb);\n          \n//          return pb;// * proportionTraveled;\n         \n//      }\n//      return 0.5;//Math.min(1,((timeToNext)%4/4));//Math.min(n.nextTime-n.time,1) \n// })\n// .pitch((n) => scaleArray[n.pitch.valueOf()+transpose])\n// .map((t) => [{time:t.time}, {time:t.time+1}, {time:t.time+1.5} , {time:t.time+2}, {time:t.time+2.5}, {time:t.time+3},{time:t.time+4}, {time:t.time+3.5} ])\n// .bjorklund(16,13,0)\n\n//  .swing(0.25,swingAmount)\n\n// // .delay(4.25)\n// .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? 41: c.pitch, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n\n// .notePlay();\n\n\n// // export var melody3 = rootMelody\n// // .metro(0.5)\n// // // .duration((n) => n.duration / 2)\n// // .bjorklund(8,3,1)\n// //  .swing(0.25,swingAmount)\n// // .pitch((n) => n.pitch-7)\n// // // .delay(4.25)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 3: c.pitch+4, velocity:sameTime ? c.velocity*0.8: c.velocity+0, duration: sameTime ? c.duration*4: c.duration*3}\n// // }, melody)\n// // .map((n) => [{pitch: n.pitch+3, time:n.time\n// // //+Math.random()*0.4-0.2\n// // }, {pitch: n.pitch}])\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-transpose])\n// // .velocity([0.5,0.7,0.5,0.3])\n\n// // .notePlay();\n\n\n// // export var pitchb3 = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .duration((n) => n.duration*0.9) \n// // .eventCount()\n// // .prop(\"pitchBend\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     //var timePassed2=1-(Math.abs(timePassed -0.5)*2);\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // })\n\n// //  .velocity(0.7)\n// // //  .pitch(60)\n\n// // // .pitch((n) => scaleArray[n.pitch.valueOf()-9])\n// // .notePlay()\n// // .automatePlay(\"pitchBend\")\n// // ;\n\n\n// // export var pitchb_concept_test = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .eventCount()\n// // .notePlay()\n// // .merge()\n// // .set(\"pitchBend\", (n) => m.evt({type:\"automation\"}).metro(1/128).set({value:}))\n// // .automatePlay(\"pitchBend_old\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // }).automatePlay(\"pitchBend\", );\n\n// // //console.log(\"PITCHBEND\",pitchbend.take(10).toArray());\n\n      "
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melody\",melody);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melody\",melody);\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    //.pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    //.pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melodydef\",melody.take(5).toArray());\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    //.pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melodydef\",melody=);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    //.pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    // .velocity(0.8)\n    //.pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
1	"\n\n\n\nexport var kick=m.evt({pitch:60, velocity:0.9, duration:0.5}).metro(0.25).bjorklund(16,9,1);//.notePlay();\n\n\n\n   \n// // import {Yegros_Transformed} from \"./externalSeq\";\n import {progression,bassprog,Yegros_Transformed,cesaria,ostinato} from \"./abletonClip\";\n\n\nexport var tst = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);\n// // console.log(Yegros_Transformed.take(50).toArray());\n\n// // throw \"bye\";\n\n// export var kick=m.evt({pitch:40, velocity:0.9, duration:0.5}).metro(1).notePlay();\n\n//export var failMe=m.data([{pitch:60, velocity:0.9, duration:5, time:0},{pitch:60, velocity:0.9, duration:1, time:2}]).notePlay().cache();\n\n// export var cowbell = m.evt({pitch:60, velocity: [0.8,0.5,0.3], duration:0.1})\n// .metro(0.25)\n\n// .bjorklund(16,9,0)\n// .swing(0.25, 0.05);\n\n\n\n\n\n\n// export var kick2=m.evt({pitch:60, velocity:0.9, duration:7}).metro(8).automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);//.notePlay().cache();\n\n\nexport var kick3=m.evt({pitch:[47,45], velocity:0.9, duration:0.2, color:[\"white\",\"orange\",\"red\"]}).metro(2/3).bjorklund(16,16,0);//.notePlay().cache();\n\nexport var kickMerged = kick3.merge(kick.pitch((n)=>n.pitch+12));    \n// export var kick4 = kick3.metro(0.5).merge(kick)\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25).delay(1);//.notePlay().cache();\n\n// export var kick5 = kick4.pitch(n => n.pitch -12);//.notePlay();\n\nexport var hat = m.evt({pitch:30, duration:0.2,velocity:[0.5,0.7,0.8]}).metro(0.25).bjorklund(16,6,0)\n.automate(\"param1\", (n) => {\n var period =2.5;\n     var easingFunc = easer().using(\"in-expo\");\n     var x = ((n.evt.time) % (period))/(period);\n    var prop = x;// easingFunc(x);\n return prop;\n})\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25)\n\n//  .swing(0.25,0.1)\n\n// .bjorklund(8,5,2)\n// .automate(\"param1\", (n) => {\n//  var period =2.5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param2\", (n) => {\n//  var period =4;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;//easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param3\", (n) => {\n//  var period = 5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// }); \n\n// .notePlay().cache();\n\n\nexport var hat3 = m.evt({pitch:60, duration:0.2,velocity:[0.5,0.7,0.8,0.6]}).metro(0.25).combineMap((c) => {\n    var sameTime = c.other.next && c.other.next.time == c.time;\n    var res=[{duration:0.1, velocity:  sameTime ? 0.4 : c.velocity, time:c.time, pitch: sameTime?c.pitch+12:c.pitch}];\n    var res2={duration:0.1, velocity:  0.5, time:c.time+0.25, pitch:c.pitch+12};\n    //console.log(\"REES\",res);\n    if (sameTime)\n        res.push(res2);\n    return res;\n},kick3)\n.swing(0.5,0.2)\n// .quantize(0.5,1)\n .delay(0.5)\n.durationsFromTime()\n.automate(\"param1\", (n) => {\n console.log(\"p1\",n);\n return easer().using(\"out-cubic\")(1-((n.time+n.evt.time) % (4))/(4));\n});\nconsole.log(\"tomtomtomtom\");\n\n//.notePlay().cache();\n\n\n\n// var getScale = (noteCount, offset) => m.count(0,1).bjorklund(12,noteCount,offset).takeWhile((n) => n<127);\n\n// var inScale = (scale, pitches) => _.intersection(scale, _.uniq(pitches)).length == _.uniq(pitches).length;\n\n\n// var transpose = -0;\n// var scaleNoteCount = 7;\n// var scaleOffset =0;\n\n// var melodyTranspose = 0;\n// // find scale\n\n//  var pitches = [61,66,57,64,56,61,61,63,64,64,56,61];\n// //var pitches = [53,69,65,61,50,57];\n// var melodyPitches = m.data(pitches);\n\n// var foundScale;\n\n//  console.log(\"PITCHES IN MELODY\",_.uniq(melodyPitches.toArray()));\n\n// for (scaleOffset=0; scaleOffset<12; scaleOffset++) {\n//     foundScale = getScale(scaleNoteCount, scaleOffset);\n//     if (inScale(foundScale.toArray(), pitches)) {\n//         console.log(\"fooound scale \"+foundScale);   \n//         break;\n//     }\n// }\n\n\n\n// var scale = foundScale;\n// var scaleArray = scale.toArray();\n// console.log(\"scaleArray \"+scale.toArray());\n\n\n\n\n// // // .map((n) => n+3)\n\n// var pitchesInScale = melodyPitches.map((n) => Math.floor(n*scaleNoteCount/12)).take(pitches.length);\n// //melodyPitches = melodyPitches.map((n) => scaleArray[Math.floor(n*scaleNoteCount/12)])\n\n// // // ;\n\n// var swingAmount = 0.1;\n// // var test1 = m.evt([{pitch:12},{pitch:13}]);\n\n// //  for (let p of melodyPitches.take(15))\n// //      console.log(\"melodyPitch\",p*scaleNoteCount/12);\n\n// var rootMelody = m.evt({pitch:pitchesInScale, duration:[1,0.5,0.5,1,0.5,0.5], velocity:[0.3,0.2,0.2,0.35]});\n\n// export var melody = rootMelody\n// .metro(1/4).duration((n) => n.duration / 2.1)\n// .bjorklund(16,9,2)\n//  .swing(0.25,swingAmount)\n// .pitch((n) => n.pitch+4+transpose)\n// .pitch((n) => scaleArray[n.pitch.valueOf()])\n// .notePlay();\n\n\n// // export var amelody = rootMelody\n\n// // .metro(4)\n\n// // .bjorklund(16,9,2)\n// // .durationsFromTime()\n// // // .swing(0.25,swingAmount)\n\n\n// //  //.map((n) => console.log(\"map\",n))\n// //  //.automate(\"pitchBend\")\n// // // .pitch((n) => n.pitch+4+transpose)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-2])\n// //  .withNext()\n \n \n// //  .map((n) => m.data(n.me).prop(\"nextTime\",n.next.time).take(1))\n\n// // console.log(\"AAAA\",amelody.take(5).toArray());\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n.combine(node.groupByTime().eventCount())\n//  .withNext()\n//  .map((n) => m.data(n.me).take(1))\n .automate(\"pitchBend\",(n) => {\n  //   console.log(\"PEEBEE\",n);\n    //  return 0.5;\n    if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n    }\n    var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n    var evtNo2 = Math.floor(n.evt.other.next.count/16);\n    var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n    var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n    var nextPitch = next.pitch.valueOf();\n    var prevPitch = prev.pitch.valueOf();\n    var mePitch=n.evt.pitch.valueOf();\n    //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n    var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n    \n  // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n    var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n    if (meLastDelta >6)\n      meLastDelta -=12;\n    // pitchNow=(96+pitchNow)%24-12;\n    // console.log((mePitch%24 - pitchNow)/24);   \n    var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n    if (meNextDelta >6)\n      meNextDelta -=12;\n    //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n   \n    var amplitude = 1;\n    var x= n.time/n.duration;\n    var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n    var easingFunc = easer().using(\"in-expo\");\n    var prop =easingFunc(xTransformed);\n  // prop = 0;\n    var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n //   console.log(\"res\",0.5 + nowDelta/12)\n    return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n }\n ).prop(\"pitchBend\", (n) => n.pitchBend );\n var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n .notePlay().merge(pbAuto.delay(delay));\n return res;\n};\n\nexport var melPBPlayer = pitchBendPlayer(ostinato,0,52,0.3,0,32).pitch((n) => n.pitch+12);\nexport var melPBPlayer2 = pitchBendPlayer(ostinato,1,52,0.5,0,32);\nexport var melPBPlayer3 = pitchBendPlayer(ostinato,0,52,0.4,0,32);\n//export var melPBPlayer3 = pitchBendPlayer(progression,3,50,0,0.5);\nexport var deeperPBPlayer = pitchBendPlayer(ostinato,0,62,0,0,1/6);\nexport var deeperPBPlayer2 = pitchBendPlayer(ostinato,0,54,0,0,1.5);\n//console.log(melPBPlayer.take(5).toArray());\n\n// // throw \"hi\";\n// // export var melody2 = rootMelody\n// // .metro(1/4)\n// // .duration((n) => n.duration / 2)\n// // .bjorklund(16,13,2)\n// //  .swing(0.25,swingAmount)\n\n// // // .delay(4.25)\n// // .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 7+transpose: c.pitch+11-transpose, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()])\n// // .notePlay();\n\n\n// export var melody4 = rootMelody\n// .metro(1)\n// .duration((n) => n.duration)\n// //.delay([0,0.5,1,2,3,4])\n\n \n\n//  .withNext()\n \n \n//  .map((n) => m.data(n.me).set({nextTime:n.next.time, nextPitch:n.next.pitch, myPitch:n.me.pitch, myTime: n.me.time}).take(1))\n//  .automate(\"pitchBend\",(n) => {\n\n//      //Math.min(n.nextTime-n.time,1));\n//     // console.log(\"hey\",n);\n//     var timeToNext = n.evt.nextTime - n.time- n.evt.myTime;\n//     // console.log(\"ttn\",timeToNext);\n//      if (timeToNext < 64) {\n//          var pitchNext = n.evt.nextPitch;\n//           var myPitch = n.evt.myPitch;\n//           var speed = 2;\n//           var totalDistance = (pitchNext-myPitch)/12*4/speed;\n//         //   var proportionTraveled = 1-timeToNext/32;\n//         //   console.log(\"proportionTraveled\", proportionTraveled);\n//           //console.log(Math.random()*proportionTraveled);\n//           var dist = n.evt.nextTime - n.evt.myTime;\n//          var propTraveled = 1-timeToNext/dist; \n//         //  if (propTraveled < 0.5 && propTraveled > -0.1)\n//         //     return (propTraveled/0.5)/40+0.5;\n//          var pb = Math.max(0,(propTraveled-1/speed))*totalDistance/2+0.5;\n//         //   console.log(\"propTraveled\",propTraveled,totalDistance,pb);\n          \n//          return pb;// * proportionTraveled;\n         \n//      }\n//      return 0.5;//Math.min(1,((timeToNext)%4/4));//Math.min(n.nextTime-n.time,1) \n// })\n// .pitch((n) => scaleArray[n.pitch.valueOf()+transpose])\n// .map((t) => [{time:t.time}, {time:t.time+1}, {time:t.time+1.5} , {time:t.time+2}, {time:t.time+2.5}, {time:t.time+3},{time:t.time+4}, {time:t.time+3.5} ])\n// .bjorklund(16,13,0)\n\n//  .swing(0.25,swingAmount)\n\n// // .delay(4.25)\n// .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? 41: c.pitch, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n\n// .notePlay();\n\n\n// // export var melody3 = rootMelody\n// // .metro(0.5)\n// // // .duration((n) => n.duration / 2)\n// // .bjorklund(8,3,1)\n// //  .swing(0.25,swingAmount)\n// // .pitch((n) => n.pitch-7)\n// // // .delay(4.25)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 3: c.pitch+4, velocity:sameTime ? c.velocity*0.8: c.velocity+0, duration: sameTime ? c.duration*4: c.duration*3}\n// // }, melody)\n// // .map((n) => [{pitch: n.pitch+3, time:n.time\n// // //+Math.random()*0.4-0.2\n// // }, {pitch: n.pitch}])\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-transpose])\n// // .velocity([0.5,0.7,0.5,0.3])\n\n// // .notePlay();\n\n\n// // export var pitchb3 = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .duration((n) => n.duration*0.9) \n// // .eventCount()\n// // .prop(\"pitchBend\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     //var timePassed2=1-(Math.abs(timePassed -0.5)*2);\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // })\n\n// //  .velocity(0.7)\n// // //  .pitch(60)\n\n// // // .pitch((n) => scaleArray[n.pitch.valueOf()-9])\n// // .notePlay()\n// // .automatePlay(\"pitchBend\")\n// // ;\n\n\n// // export var pitchb_concept_test = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .eventCount()\n// // .notePlay()\n// // .merge()\n// // .set(\"pitchBend\", (n) => m.evt({type:\"automation\"}).metro(1/128).set({value:}))\n// // .automatePlay(\"pitchBend_old\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // }).automatePlay(\"pitchBend\", );\n\n// // //console.log(\"PITCHBEND\",pitchbend.take(10).toArray());\n\n      "
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0],velocity:0.8})))\n    // .velocity(0.8)\n    //.pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0],velocity:0.8})))\n    .velocity(0.8)\n    //.pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.evt(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0],velocity:0.8})))\n    .velocity(0.8)\n    //.pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.evt(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0],velocity:0.8})))\n    .velocity(0.8)\n    //.pitch(toScale)\n    .loopLength(8);\nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
1	"\n\n\n\nexport var kick=m.evt({pitch:60, velocity:0.9, duration:0.5}).metro(0.25).bjorklund(16,9,1);//.notePlay();\n\n\n\n   \n// // import {Yegros_Transformed} from \"./externalSeq\";\n import {progression,bassprog,Yegros_Transformed,cesaria,ostinato} from \"./abletonClip\";\n\n\nexport var tst = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);\n// // console.log(Yegros_Transformed.take(50).toArray());\n\n// // throw \"bye\";\n\n// export var kick=m.evt({pitch:40, velocity:0.9, duration:0.5}).metro(1).notePlay();\n\n//export var failMe=m.data([{pitch:60, velocity:0.9, duration:5, time:0},{pitch:60, velocity:0.9, duration:1, time:2}]).notePlay().cache();\n\n// export var cowbell = m.evt({pitch:60, velocity: [0.8,0.5,0.3], duration:0.1})\n// .metro(0.25)\n\n// .bjorklund(16,9,0)\n// .swing(0.25, 0.05);\n\n\n\n\n\n\n// export var kick2=m.evt({pitch:60, velocity:0.9, duration:7}).metro(8).automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);//.notePlay().cache();\n\n\nexport var kick3=m.evt({pitch:[47,45], velocity:0.9, duration:0.2, color:[\"white\",\"orange\",\"red\"]}).metro(2/3).bjorklund(16,16,0);//.notePlay().cache();\n\nexport var kickMerged = kick3.merge(kick.pitch((n)=>n.pitch+12));    \n// export var kick4 = kick3.metro(0.5).merge(kick)\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25).delay(1);//.notePlay().cache();\n\n// export var kick5 = kick4.pitch(n => n.pitch -12);//.notePlay();\n\nexport var hat = m.evt({pitch:30, duration:0.2,velocity:[0.5,0.7,0.8]}).metro(0.25).bjorklund(16,6,0)\n.automate(\"param1\", (n) => {\n var period =2.5;\n     var easingFunc = easer().using(\"in-expo\");\n     var x = ((n.evt.time) % (period))/(period);\n    var prop = x;// easingFunc(x);\n return prop;\n})\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25)\n\n//  .swing(0.25,0.1)\n\n// .bjorklund(8,5,2)\n// .automate(\"param1\", (n) => {\n//  var period =2.5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param2\", (n) => {\n//  var period =4;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;//easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param3\", (n) => {\n//  var period = 5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// }); \n\n// .notePlay().cache();\n\n\nexport var hat3 = m.evt({pitch:60, duration:0.2,velocity:[0.5,0.7,0.8,0.6]}).metro(0.25).combineMap((c) => {\n    var sameTime = c.other.next && c.other.next.time == c.time;\n    var res=[{duration:0.1, velocity:  sameTime ? 0.4 : c.velocity, time:c.time, pitch: sameTime?c.pitch+12:c.pitch}];\n    var res2={duration:0.1, velocity:  0.5, time:c.time+0.25, pitch:c.pitch+12};\n    //console.log(\"REES\",res);\n    if (sameTime)\n        res.push(res2);\n    return res;\n},kick3)\n.swing(0.5,0.2)\n// .quantize(0.5,1)\n .delay(0.5)\n.durationsFromTime()\n.automate(\"param1\", (n) => {\n console.log(\"p1\",n);\n return easer().using(\"out-cubic\")(1-((n.time+n.evt.time) % (4))/(4));\n});\nconsole.log(\"tomtomtomtom\");\n\n//.notePlay().cache();\n\n\n\n// var getScale = (noteCount, offset) => m.count(0,1).bjorklund(12,noteCount,offset).takeWhile((n) => n<127);\n\n// var inScale = (scale, pitches) => _.intersection(scale, _.uniq(pitches)).length == _.uniq(pitches).length;\n\n\n// var transpose = -0;\n// var scaleNoteCount = 7;\n// var scaleOffset =0;\n\n// var melodyTranspose = 0;\n// // find scale\n\n//  var pitches = [61,66,57,64,56,61,61,63,64,64,56,61];\n// //var pitches = [53,69,65,61,50,57];\n// var melodyPitches = m.data(pitches);\n\n// var foundScale;\n\n//  console.log(\"PITCHES IN MELODY\",_.uniq(melodyPitches.toArray()));\n\n// for (scaleOffset=0; scaleOffset<12; scaleOffset++) {\n//     foundScale = getScale(scaleNoteCount, scaleOffset);\n//     if (inScale(foundScale.toArray(), pitches)) {\n//         console.log(\"fooound scale \"+foundScale);   \n//         break;\n//     }\n// }\n\n\n\n// var scale = foundScale;\n// var scaleArray = scale.toArray();\n// console.log(\"scaleArray \"+scale.toArray());\n\n\n\n\n// // // .map((n) => n+3)\n\n// var pitchesInScale = melodyPitches.map((n) => Math.floor(n*scaleNoteCount/12)).take(pitches.length);\n// //melodyPitches = melodyPitches.map((n) => scaleArray[Math.floor(n*scaleNoteCount/12)])\n\n// // // ;\n\n// var swingAmount = 0.1;\n// // var test1 = m.evt([{pitch:12},{pitch:13}]);\n\n// //  for (let p of melodyPitches.take(15))\n// //      console.log(\"melodyPitch\",p*scaleNoteCount/12);\n\n// var rootMelody = m.evt({pitch:pitchesInScale, duration:[1,0.5,0.5,1,0.5,0.5], velocity:[0.3,0.2,0.2,0.35]});\n\n// export var melody = rootMelody\n// .metro(1/4).duration((n) => n.duration / 2.1)\n// .bjorklund(16,9,2)\n//  .swing(0.25,swingAmount)\n// .pitch((n) => n.pitch+4+transpose)\n// .pitch((n) => scaleArray[n.pitch.valueOf()])\n// .notePlay();\n\n\n// // export var amelody = rootMelody\n\n// // .metro(4)\n\n// // .bjorklund(16,9,2)\n// // .durationsFromTime()\n// // // .swing(0.25,swingAmount)\n\n\n// //  //.map((n) => console.log(\"map\",n))\n// //  //.automate(\"pitchBend\")\n// // // .pitch((n) => n.pitch+4+transpose)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-2])\n// //  .withNext()\n \n \n// //  .map((n) => m.data(n.me).prop(\"nextTime\",n.next.time).take(1))\n\n// // console.log(\"AAAA\",amelody.take(5).toArray());\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n.combine(node.groupByTime().eventCount())\n//  .withNext()\n//  .map((n) => m.data(n.me).take(1))\n .automate(\"pitchBend\",(n) => {\n  //   console.log(\"PEEBEE\",n);\n    //  return 0.5;\n    if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n    }\n    var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n    var evtNo2 = Math.floor(n.evt.other.next.count/16);\n    var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n    var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n    var nextPitch = next.pitch.valueOf();\n    var prevPitch = prev.pitch.valueOf();\n    var mePitch=n.evt.pitch.valueOf();\n    //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n    var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n    \n  // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n    var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n    if (meLastDelta >6)\n      meLastDelta -=12;\n    // pitchNow=(96+pitchNow)%24-12;\n    // console.log((mePitch%24 - pitchNow)/24);   \n    var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n    if (meNextDelta >6)\n      meNextDelta -=12;\n    //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n   \n    var amplitude = 1;\n    var x= n.time/n.duration;\n    var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n    var easingFunc = easer().using(\"in-expo\");\n    var prop =easingFunc(xTransformed);\n  // prop = 0;\n    var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n //   console.log(\"res\",0.5 + nowDelta/12)\n    return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n }\n ).prop(\"pitchBend\", (n) => n.pitchBend );\n var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n .notePlay().merge(pbAuto.delay(delay));\n return res;\n};\n\nexport var melPBPlayer = pitchBendPlayer(ostinato,0,52,0.3,0,32).pitch((n) => n.pitch+12);\nexport var melPBPlayer2 = pitchBendPlayer(ostinato,1,52,0.5,0,32);\nexport var melPBPlayer3 = pitchBendPlayer(ostinato,0,52,0.4,0,32);\n//export var melPBPlayer3 = pitchBendPlayer(progression,3,50,0,0.5);\nexport var deeperPBPlayer = pitchBendPlayer(ostinato,0,62,0,0,1/6);\nexport var deeperPBPlayer2 = pitchBendPlayer(ostinato,0,54,0,0,1.5);\n//console.log(melPBPlayer.take(5).toArray());\n\n// // throw \"hi\";\n// // export var melody2 = rootMelody\n// // .metro(1/4)\n// // .duration((n) => n.duration / 2)\n// // .bjorklund(16,13,2)\n// //  .swing(0.25,swingAmount)\n\n// // // .delay(4.25)\n// // .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 7+transpose: c.pitch+11-transpose, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()])\n// // .notePlay();\n\n\n// export var melody4 = rootMelody\n// .metro(1)\n// .duration((n) => n.duration)\n// //.delay([0,0.5,1,2,3,4])\n\n \n\n//  .withNext()\n \n \n//  .map((n) => m.data(n.me).set({nextTime:n.next.time, nextPitch:n.next.pitch, myPitch:n.me.pitch, myTime: n.me.time}).take(1))\n//  .automate(\"pitchBend\",(n) => {\n\n//      //Math.min(n.nextTime-n.time,1));\n//     // console.log(\"hey\",n);\n//     var timeToNext = n.evt.nextTime - n.time- n.evt.myTime;\n//     // console.log(\"ttn\",timeToNext);\n//      if (timeToNext < 64) {\n//          var pitchNext = n.evt.nextPitch;\n//           var myPitch = n.evt.myPitch;\n//           var speed = 2;\n//           var totalDistance = (pitchNext-myPitch)/12*4/speed;\n//         //   var proportionTraveled = 1-timeToNext/32;\n//         //   console.log(\"proportionTraveled\", proportionTraveled);\n//           //console.log(Math.random()*proportionTraveled);\n//           var dist = n.evt.nextTime - n.evt.myTime;\n//          var propTraveled = 1-timeToNext/dist; \n//         //  if (propTraveled < 0.5 && propTraveled > -0.1)\n//         //     return (propTraveled/0.5)/40+0.5;\n//          var pb = Math.max(0,(propTraveled-1/speed))*totalDistance/2+0.5;\n//         //   console.log(\"propTraveled\",propTraveled,totalDistance,pb);\n          \n//          return pb;// * proportionTraveled;\n         \n//      }\n//      return 0.5;//Math.min(1,((timeToNext)%4/4));//Math.min(n.nextTime-n.time,1) \n// })\n// .pitch((n) => scaleArray[n.pitch.valueOf()+transpose])\n// .map((t) => [{time:t.time}, {time:t.time+1}, {time:t.time+1.5} , {time:t.time+2}, {time:t.time+2.5}, {time:t.time+3},{time:t.time+4}, {time:t.time+3.5} ])\n// .bjorklund(16,13,0)\n\n//  .swing(0.25,swingAmount)\n\n// // .delay(4.25)\n// .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? 41: c.pitch, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n\n// .notePlay();\n\n\n// // export var melody3 = rootMelody\n// // .metro(0.5)\n// // // .duration((n) => n.duration / 2)\n// // .bjorklund(8,3,1)\n// //  .swing(0.25,swingAmount)\n// // .pitch((n) => n.pitch-7)\n// // // .delay(4.25)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 3: c.pitch+4, velocity:sameTime ? c.velocity*0.8: c.velocity+0, duration: sameTime ? c.duration*4: c.duration*3}\n// // }, melody)\n// // .map((n) => [{pitch: n.pitch+3, time:n.time\n// // //+Math.random()*0.4-0.2\n// // }, {pitch: n.pitch}])\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-transpose])\n// // .velocity([0.5,0.7,0.5,0.3])\n\n// // .notePlay();\n\n\n// // export var pitchb3 = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .duration((n) => n.duration*0.9) \n// // .eventCount()\n// // .prop(\"pitchBend\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     //var timePassed2=1-(Math.abs(timePassed -0.5)*2);\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // })\n\n// //  .velocity(0.7)\n// // //  .pitch(60)\n\n// // // .pitch((n) => scaleArray[n.pitch.valueOf()-9])\n// // .notePlay()\n// // .automatePlay(\"pitchBend\")\n// // ;\n\n\n// // export var pitchb_concept_test = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .eventCount()\n// // .notePlay()\n// // .merge()\n// // .set(\"pitchBend\", (n) => m.evt({type:\"automation\"}).metro(1/128).set({value:}))\n// // .automatePlay(\"pitchBend_old\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // }).automatePlay(\"pitchBend\", );\n\n// // //console.log(\"PITCHBEND\",pitchbend.take(10).toArray());\n\n      "
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.evt(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
1	"\n\n\n\nexport var kick=m.evt({pitch:60, velocity:0.9, duration:0.5}).metro(0.25).bjorklund(16,9,1);//.notePlay();\n\n\n\n   \n// // import {Yegros_Transformed} from \"./externalSeq\";\n import {progression,bassprog,Yegros_Transformed,cesaria,ostinato} from \"./abletonClip\";\n\n\nexport var tst = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);\n// // console.log(Yegros_Transformed.take(50).toArray());\n\n// // throw \"bye\";\n\n// export var kick=m.evt({pitch:40, velocity:0.9, duration:0.5}).metro(1).notePlay();\n\n//export var failMe=m.data([{pitch:60, velocity:0.9, duration:5, time:0},{pitch:60, velocity:0.9, duration:1, time:2}]).notePlay().cache();\n\n// export var cowbell = m.evt({pitch:60, velocity: [0.8,0.5,0.3], duration:0.1})\n// .metro(0.25)\n\n// .bjorklund(16,9,0)\n// .swing(0.25, 0.05);\n\n\n\n\n\n\n// export var kick2=m.evt({pitch:60, velocity:0.9, duration:7}).metro(8).automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);//.notePlay().cache();\n\n\nexport var kick3=m.evt({pitch:[47,45], velocity:0.9, duration:0.2, color:[\"white\",\"orange\",\"red\"]}).metro(2/3).bjorklund(16,16,0);//.notePlay().cache();\n\nexport var kickMerged = kick3.merge(kick.pitch((n)=>n.pitch+12));    \n// export var kick4 = kick3.metro(0.5).merge(kick)\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25).delay(1);//.notePlay().cache();\n\n// export var kick5 = kick4.pitch(n => n.pitch -12);//.notePlay();\n\nexport var hat = m.evt({pitch:30, duration:0.2,velocity:[0.5,0.7,0.8]}).metro(0.25).bjorklund(16,6,0)\n.automate(\"param1\", (n) => {\n var period =2.5;\n     var easingFunc = easer().using(\"in-expo\");\n     var x = ((n.evt.time) % (period))/(period);\n    var prop = x;// easingFunc(x);\n return prop;\n})\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*3)/8)+0.25)\n\n//  .swing(0.25,0.1)\n\n// .bjorklund(8,5,2)\n// .automate(\"param1\", (n) => {\n//  var period =2.5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param2\", (n) => {\n//  var period =4;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;//easingFunc(x);\n//  return prop;\n// })\n// .automate(\"param3\", (n) => {\n//  var period = 5;\n//      var easingFunc = easer().using(\"in-expo\");\n//      var x = ((n.evt.time) % (period))/(period);\n//     var prop = x;// easingFunc(x);\n//  return prop;\n// }); \n\n// .notePlay().cache();\n\n\nexport var hat3 = m.evt({pitch:60, duration:0.2,velocity:[0.5,0.7,0.8,0.6]}).metro(0.25).combineMap((c) => {\n    var sameTime = c.other.next && c.other.next.time == c.time;\n    var res=[{duration:0.1, velocity:  sameTime ? 0.4 : c.velocity, time:c.time, pitch: sameTime?c.pitch+12:c.pitch}];\n    var res2={duration:0.1, velocity:  0.5, time:c.time+0.25, pitch:c.pitch+12};\n    //console.log(\"REES\",res);\n    if (sameTime)\n        res.push(res2);\n    return res;\n},kick3)\n.swing(0.5,0.2)\n// .quantize(0.5,1)\n .delay(0.5)\n.durationsFromTime()\n.automate(\"param1\", (n) => {\n console.log(\"p1\",n);\n return easer().using(\"out-cubic\")(1-((n.time+n.evt.time) % (4))/(4));\n});\nconsole.log(\"tomtomtomtom\");\n\n//.notePlay().cache();\n\n\n\n// var getScale = (noteCount, offset) => m.count(0,1).bjorklund(12,noteCount,offset).takeWhile((n) => n<127);\n\n// var inScale = (scale, pitches) => _.intersection(scale, _.uniq(pitches)).length == _.uniq(pitches).length;\n\n\n// var transpose = -0;\n// var scaleNoteCount = 7;\n// var scaleOffset =0;\n\n// var melodyTranspose = 0;\n// // find scale\n\n//  var pitches = [61,66,57,64,56,61,61,63,64,64,56,61];\n// //var pitches = [53,69,65,61,50,57];\n// var melodyPitches = m.data(pitches);\n\n// var foundScale;\n\n//  console.log(\"PITCHES IN MELODY\",_.uniq(melodyPitches.toArray()));\n\n// for (scaleOffset=0; scaleOffset<12; scaleOffset++) {\n//     foundScale = getScale(scaleNoteCount, scaleOffset);\n//     if (inScale(foundScale.toArray(), pitches)) {\n//         console.log(\"fooound scale \"+foundScale);   \n//         break;\n//     }\n// }\n\n\n\n// var scale = foundScale;\n// var scaleArray = scale.toArray();\n// console.log(\"scaleArray \"+scale.toArray());\n\n\n\n\n// // // .map((n) => n+3)\n\n// var pitchesInScale = melodyPitches.map((n) => Math.floor(n*scaleNoteCount/12)).take(pitches.length);\n// //melodyPitches = melodyPitches.map((n) => scaleArray[Math.floor(n*scaleNoteCount/12)])\n\n// // // ;\n\n// var swingAmount = 0.1;\n// // var test1 = m.evt([{pitch:12},{pitch:13}]);\n\n// //  for (let p of melodyPitches.take(15))\n// //      console.log(\"melodyPitch\",p*scaleNoteCount/12);\n\n// var rootMelody = m.evt({pitch:pitchesInScale, duration:[1,0.5,0.5,1,0.5,0.5], velocity:[0.3,0.2,0.2,0.35]});\n\n// export var melody = rootMelody\n// .metro(1/4).duration((n) => n.duration / 2.1)\n// .bjorklund(16,9,2)\n//  .swing(0.25,swingAmount)\n// .pitch((n) => n.pitch+4+transpose)\n// .pitch((n) => scaleArray[n.pitch.valueOf()])\n// .notePlay();\n\n\n// // export var amelody = rootMelody\n\n// // .metro(4)\n\n// // .bjorklund(16,9,2)\n// // .durationsFromTime()\n// // // .swing(0.25,swingAmount)\n\n\n// //  //.map((n) => console.log(\"map\",n))\n// //  //.automate(\"pitchBend\")\n// // // .pitch((n) => n.pitch+4+transpose)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-2])\n// //  .withNext()\n \n \n// //  .map((n) => m.data(n.me).prop(\"nextTime\",n.next.time).take(1))\n\n// // console.log(\"AAAA\",amelody.take(5).toArray());\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n.combine(node.groupByTime().eventCount())\n//  .withNext()\n//  .map((n) => m.data(n.me).take(1))\n .automate(\"pitchBend\",(n) => {\n  //   console.log(\"PEEBEE\",n);\n    //  return 0.5;\n    if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n    }\n    var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n    var evtNo2 = Math.floor(n.evt.other.next.count/16);\n    var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n    var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n    var nextPitch = next.pitch.valueOf();\n    var prevPitch = prev.pitch.valueOf();\n    var mePitch=n.evt.pitch.valueOf();\n    //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n    var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n    \n  // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n    var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n    if (meLastDelta >6)\n      meLastDelta -=12;\n    // pitchNow=(96+pitchNow)%24-12;\n    // console.log((mePitch%24 - pitchNow)/24);   \n    var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n    if (meNextDelta >6)\n      meNextDelta -=12;\n    //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n   \n    var amplitude = 1;\n    var x= n.time/n.duration;\n    var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n    var easingFunc = easer().using(\"in-expo\");\n    var prop =easingFunc(xTransformed);\n  // prop = 0;\n    var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n //   console.log(\"res\",0.5 + nowDelta/12)\n    return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n }\n ).prop(\"pitchBend\", (n) => n.pitchBend );\n var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n .notePlay().merge(pbAuto.delay(delay));\n return res;\n};\n\nexport var melPBPlayer = pitchBendPlayer(ostinato,0,52,0.3,0,32).pitch((n) => n.pitch+12);\nexport var melPBPlayer2 = pitchBendPlayer(ostinato,1,52,0.5,0,32);\nexport var melPBPlayer3 = pitchBendPlayer(ostinato,0,52,0.4,0,32);\n//export var melPBPlayer3 = pitchBendPlayer(progression,3,50,0,0.5);\nexport var deeperPBPlayer = pitchBendPlayer(ostinato,0,62,0,0,1/6);\nexport var deeperPBPlayer2 = pitchBendPlayer(ostinato,0,54,0,0,1.5);\n//console.log(melPBPlayer.take(5).toArray());\n\n// // throw \"hi\";\n// // export var melody2 = rootMelody\n// // .metro(1/4)\n// // .duration((n) => n.duration / 2)\n// // .bjorklund(16,13,2)\n// //  .swing(0.25,swingAmount)\n\n// // // .delay(4.25)\n// // .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 7+transpose: c.pitch+11-transpose, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n// // .pitch((n) => scaleArray[n.pitch.valueOf()])\n// // .notePlay();\n\n\n// export var melody4 = rootMelody\n// .metro(1)\n// .duration((n) => n.duration)\n// //.delay([0,0.5,1,2,3,4])\n\n \n\n//  .withNext()\n \n \n//  .map((n) => m.data(n.me).set({nextTime:n.next.time, nextPitch:n.next.pitch, myPitch:n.me.pitch, myTime: n.me.time}).take(1))\n//  .automate(\"pitchBend\",(n) => {\n\n//      //Math.min(n.nextTime-n.time,1));\n//     // console.log(\"hey\",n);\n//     var timeToNext = n.evt.nextTime - n.time- n.evt.myTime;\n//     // console.log(\"ttn\",timeToNext);\n//      if (timeToNext < 64) {\n//          var pitchNext = n.evt.nextPitch;\n//           var myPitch = n.evt.myPitch;\n//           var speed = 2;\n//           var totalDistance = (pitchNext-myPitch)/12*4/speed;\n//         //   var proportionTraveled = 1-timeToNext/32;\n//         //   console.log(\"proportionTraveled\", proportionTraveled);\n//           //console.log(Math.random()*proportionTraveled);\n//           var dist = n.evt.nextTime - n.evt.myTime;\n//          var propTraveled = 1-timeToNext/dist; \n//         //  if (propTraveled < 0.5 && propTraveled > -0.1)\n//         //     return (propTraveled/0.5)/40+0.5;\n//          var pb = Math.max(0,(propTraveled-1/speed))*totalDistance/2+0.5;\n//         //   console.log(\"propTraveled\",propTraveled,totalDistance,pb);\n          \n//          return pb;// * proportionTraveled;\n         \n//      }\n//      return 0.5;//Math.min(1,((timeToNext)%4/4));//Math.min(n.nextTime-n.time,1) \n// })\n// .pitch((n) => scaleArray[n.pitch.valueOf()+transpose])\n// .map((t) => [{time:t.time}, {time:t.time+1}, {time:t.time+1.5} , {time:t.time+2}, {time:t.time+2.5}, {time:t.time+3},{time:t.time+4}, {time:t.time+3.5} ])\n// .bjorklund(16,13,0)\n\n//  .swing(0.25,swingAmount)\n\n// // .delay(4.25)\n// .velocity((n) => n.velocity*0.8)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? 41: c.pitch, velocity:sameTime ? c.velocity*0.5: c.velocity+0, duration: sameTime ? c.duration*1: c.duration*2}\n// // }, melody)\n\n// .notePlay();\n\n\n// // export var melody3 = rootMelody\n// // .metro(0.5)\n// // // .duration((n) => n.duration / 2)\n// // .bjorklund(8,3,1)\n// //  .swing(0.25,swingAmount)\n// // .pitch((n) => n.pitch-7)\n// // // .delay(4.25)\n// // .combineMap((c) => { \n// //     var sameTime = c.other.next && c.other.next.time == c.time;\n// //     return {pitch: sameTime ? c.pitch + 3: c.pitch+4, velocity:sameTime ? c.velocity*0.8: c.velocity+0, duration: sameTime ? c.duration*4: c.duration*3}\n// // }, melody)\n// // .map((n) => [{pitch: n.pitch+3, time:n.time\n// // //+Math.random()*0.4-0.2\n// // }, {pitch: n.pitch}])\n// // .pitch((n) => scaleArray[n.pitch.valueOf()-transpose])\n// // .velocity([0.5,0.7,0.5,0.3])\n\n// // .notePlay();\n\n\n// // export var pitchb3 = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .duration((n) => n.duration*0.9) \n// // .eventCount()\n// // .prop(\"pitchBend\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     //var timePassed2=1-(Math.abs(timePassed -0.5)*2);\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // })\n\n// //  .velocity(0.7)\n// // //  .pitch(60)\n\n// // // .pitch((n) => scaleArray[n.pitch.valueOf()-9])\n// // .notePlay()\n// // .automatePlay(\"pitchBend\")\n// // ;\n\n\n// // export var pitchb_concept_test = m.evt({pitch:60, velocity:0.8})\n// // .metro(4)\n// // .durationsFromTime()\n// // .eventCount()\n// // .notePlay()\n// // .merge()\n// // .set(\"pitchBend\", (n) => m.evt({type:\"automation\"}).metro(1/128).set({value:}))\n// // .automatePlay(\"pitchBend_old\", (t, e) => {\n// //     var timePassed = (t-e.time)/e.duration;\n// //     var amplitude = (1-Math.min(1,1-timePassed*1));\n// //     amplitude = Math.max(Math.pow(amplitude,2)-0.5,0);\n// //     if (timePassed < 0.3)\n// //       amplitude = (1-timePassed*5);\n// //     // amplitude = amplitude*amplitude;\n// //     return (e.count % 2 === 0 ? -1 : 1) *amplitude +  0.5;//*Math.sin(t*Math.PI*2*1)/2+0.5;\n// // }).automatePlay(\"pitchBend\", );\n\n// // //console.log(\"PITCHBEND\",pitchbend.take(10).toArray());\n\n      "
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.evt(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    // .velocity(0.8)\n    // .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    // .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    // .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0]})))\n    .velocity(0.8)\n    // .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .velocity(0.8)\n    // .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .velocity(0.8)\n    // .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n     .velocity(0.8)\n    // .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n     .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);\n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    .set({velocity:0.1})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\nconsole.log(\"mappedNote\",mapNote(scaleNotes,1));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\nconsole.log(\"mappedNote\",mapNote(scaleNotes,1));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:1}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch+(notes.length*1000))%notes.length]*Math.floor((note.pitch)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:1}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch+(notes.length*1000))%notes.length]*Math.floor((note.pitch)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:2}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch+(notes.length*1000))%notes.length]*Math.floor((note.pitch)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch+(notes.length*1000))%notes.length]*Math.floor((note.pitch)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch+(notes.length*1000))%notes.length]*Math.floor((note.pitch)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote =(notes, note) => {\n    console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]*Math.floor((note.pitch)/notes.length);\n};\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\n// var toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    // .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:11}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:10}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:12}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:11}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",mapNote(scaleNotes,{pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+12)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, n.pitch-1},n]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, n.pitch+1},n]);\n\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[1, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, n.pitch-1},n]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, n.pitch+1},n]);\n\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[1, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},n]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},n]);\n\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},n]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},n]);\n\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},n]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},n]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(melodyTheme.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},n]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},n]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},n]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},n]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},n]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},n]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},n]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},n]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},n]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},n]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},n]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},n]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\n\nconsole.log(\"bnotemap\",baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nconsole.log(\"rying bnotemap\");\nvar baseNote = m.data({velocity:0.8, duration:1});\n\nconsole.log(\"bnotemap\",baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\nconsole.log(\"bnotemap\",baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
abletonClip	";\n export var transparent chords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);"
abletonClip	";\n export var transparent chords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\nconsole.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\nconsole.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n// import {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\nconsole.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n// import {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\nconsole.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\n// import {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(tranparentChords,0,52,0.3,0,16);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,16);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(tranparentChords,0,52,0.3,0,16);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,16);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(tranparentChords,0,52,0.3,0,16);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,16);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\n// var pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n//     var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n//     .combine(node.groupByTime().eventCount())\n//     //  .withNext()\n//     //  .map((n) => m.data(n.me).take(1))\n//     .automate(\"pitchBend\",(n) => {\n//       //   console.log(\"PEEBEE\",n);\n//       //  return 0.5;\n//       if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n//         console.warn(\"dont have enough polyphony for this pitchBend automation\");\n//         console.log(n);\n//         console.log(n.evt.other);\n//         return 0.5;\n//       }\n//       var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n//       var evtNo2 = Math.floor(n.evt.other.next.count/16);\n//       var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n//       var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n//       var nextPitch = next.pitch.valueOf();\n//       var prevPitch = prev.pitch.valueOf();\n//       var mePitch=n.evt.pitch.valueOf();\n//       //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n//       var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n//       // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n//       var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n//       if (meLastDelta >6)\n//         meLastDelta -=12;\n//         // pitchNow=(96+pitchNow)%24-12;\n//         // console.log((mePitch%24 - pitchNow)/24);   \n//         var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n//         if (meNextDelta >6)\n//           meNextDelta -=12;\n//           //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n//           var amplitude = 1;\n//           var x= n.time/n.duration;\n//           var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n//           var easingFunc = easer().using(\"in-expo\");\n//           var prop =easingFunc(xTransformed);\n//           // prop = 0;\n//           var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//           //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n//           //   console.log(\"res\",0.5 + nowDelta/12)\n//           return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n//         }\n//       ).prop(\"pitchBend\", (n) => n.pitchBend );\n//       var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n//       .notePlay().merge(pbAuto.delay(delay));\n//       return res;\n//     };\n    \n//     export var transPB1 = pitchBendPlayer(tranparentChords,0,52,0.3,0,16);\n//     export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,16);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\nvar melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\nconsole.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\n// var pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n//     var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n//     .combine(node.groupByTime().eventCount())\n//     //  .withNext()\n//     //  .map((n) => m.data(n.me).take(1))\n//     .automate(\"pitchBend\",(n) => {\n//       //   console.log(\"PEEBEE\",n);\n//       //  return 0.5;\n//       if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n//         console.warn(\"dont have enough polyphony for this pitchBend automation\");\n//         console.log(n);\n//         console.log(n.evt.other);\n//         return 0.5;\n//       }\n//       var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n//       var evtNo2 = Math.floor(n.evt.other.next.count/16);\n//       var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n//       var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n//       var nextPitch = next.pitch.valueOf();\n//       var prevPitch = prev.pitch.valueOf();\n//       var mePitch=n.evt.pitch.valueOf();\n//       //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n//       var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n//       // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n//       var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n//       if (meLastDelta >6)\n//         meLastDelta -=12;\n//         // pitchNow=(96+pitchNow)%24-12;\n//         // console.log((mePitch%24 - pitchNow)/24);   \n//         var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n//         if (meNextDelta >6)\n//           meNextDelta -=12;\n//           //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n//           var amplitude = 1;\n//           var x= n.time/n.duration;\n//           var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n//           var easingFunc = easer().using(\"in-expo\");\n//           var prop =easingFunc(xTransformed);\n//           // prop = 0;\n//           var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//           //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n//           //   console.log(\"res\",0.5 + nowDelta/12)\n//           return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n//         }\n//       ).prop(\"pitchBend\", (n) => n.pitchBend );\n//       var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n//       .notePlay().merge(pbAuto.delay(delay));\n//       return res;\n//     };\n    \n//     export var transPB1 = pitchBendPlayer(tranparentChords,0,52,0.3,0,16);\n//     export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,16);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\n// var pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n//     var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n//     .combine(node.groupByTime().eventCount())\n//     //  .withNext()\n//     //  .map((n) => m.data(n.me).take(1))\n//     .automate(\"pitchBend\",(n) => {\n//       //   console.log(\"PEEBEE\",n);\n//       //  return 0.5;\n//       if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n//         console.warn(\"dont have enough polyphony for this pitchBend automation\");\n//         console.log(n);\n//         console.log(n.evt.other);\n//         return 0.5;\n//       }\n//       var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n//       var evtNo2 = Math.floor(n.evt.other.next.count/16);\n//       var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n//       var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n//       var nextPitch = next.pitch.valueOf();\n//       var prevPitch = prev.pitch.valueOf();\n//       var mePitch=n.evt.pitch.valueOf();\n//       //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n//       var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n//       // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n//       var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n//       if (meLastDelta >6)\n//         meLastDelta -=12;\n//         // pitchNow=(96+pitchNow)%24-12;\n//         // console.log((mePitch%24 - pitchNow)/24);   \n//         var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n//         if (meNextDelta >6)\n//           meNextDelta -=12;\n//           //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n//           var amplitude = 1;\n//           var x= n.time/n.duration;\n//           var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n//           var easingFunc = easer().using(\"in-expo\");\n//           var prop =easingFunc(xTransformed);\n//           // prop = 0;\n//           var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n//           //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n//           //   console.log(\"res\",0.5 + nowDelta/12)\n//           return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n//         }\n//       ).prop(\"pitchBend\", (n) => n.pitchBend );\n//       var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n//       .notePlay().merge(pbAuto.delay(delay));\n//       return res;\n//     };\n    \n//     export var transPB1 = pitchBendPlayer(tranparentChords,0,52,0.3,0,16);\n//     export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,16);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(tranparentChords,0,52,0.3,0,16);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,16);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transparentChords,0,52,0.3,0,16);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,16);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transparentChords,0,52,0.3,0,16);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,16);\n    export var transPB3 = pitchBendPlayer(transparentChords,2,52,0.5,0,16);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transparentChords,0,52,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,32);\n    export var transPB3 = pitchBendPlayer(transparentChords,2,52,0.5,0,32);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-bounce\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transparentChords,0,52,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,32);\n    export var transPB3 = pitchBendPlayer(transparentChords,2,52,0.5,0,32);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-elastic\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transparentChords,0,52,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0.5,0,32);\n    export var transPB3 = pitchBendPlayer(transparentChords,2,52,0.5,0,32);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-elastic\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transparentChords,0,52,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transparentChords,2,52,0.5,0,32);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-elastic\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transparentChords,0,52,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transparentChords,2,52,0.2,0,32);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-elastic\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transparentChords,0,60,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transparentChords,2,52,0.2,0,32);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-elastic\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transparentChords,0,52,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transparentChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transparentChords,2,52,0.2,0,32);\n\n\n// console.log(basicProgression);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n export var transChords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-elastic\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,52,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,52,0.2,0,32);\n\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transparentChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-elastic\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,52,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,52,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-elastic\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,52,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,52,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,52,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,52,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,52,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,54,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,53,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,52,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,52,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,560,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,60,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,61,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,63,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,62,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,58,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,59,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) =>console.log(grouped) grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) =>console.log(grouped));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nvar rhythmicTrans = transChords.groupByTime().map((grouped) =>console.log(grouped));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nexport var rhythmicTrans = transChords.groupByTime().map((grouped) =>console.log(grouped));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n\nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\nconsole.log(transChords);\nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords);\n// export var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n export var transChords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords);\n// export var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords);\nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords);\nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords);\nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.map((n) => ([n.set({duration:0.1})]));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords);\nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords);\nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"param1\", (n) => Math.sin()*n.time/2+0.5)\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"param1\", (t,n) =>  {\n return   Math.sin()*n./2+0.5)\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"param1\", (t,n) =>  {\n return   Math.sin()*n.time/2+0.5;\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"param1\", (n) =>  {\n return   Math.sin()*n.time/2+0.5;\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"param2\", (n) =>  {\n return   Math.sin()*n.time/2+0.5;\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"param2\", (n) =>  {\n return   Math.sin()*n.time/2+0.5;\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"param2\", (n) =>  {\n return   Math.sin()*n.time/2+0.5;\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n export var transChords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"param2\", (n) =>  {\n return   Math.sin()*n.time/2+0.5;\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"param2\", (n) =>  {\n    console.log(n);\n return   Math.sin()*n.time/2+0.5;\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"param2\", (n) =>  {\n    console.log(n);\n return   Math.sin()*n.time/2+0.5;\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"pitchbend\", (n) =>  {\n    console.log(n);\n return   Math.sin()*n.time/2+0.5;\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"pitchbend\", (n) =>  {\n    console.log(n);\n return   1;\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"pitchbend\", (n) =>  {\n    console.log(n);\n return   2;\n});\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.map([n,n.delay(0.75)])\n.automate(\"pitchBend\",(n) => (Math.sin(n.time*4)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.map([n,n.delay(0.75)])\n.automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.map([n,n.delay(0.75),n.delay(2)])\n.automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.flatMap([n,n.delay(0.75),n.delay(2)])\n.automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\nduration(0.5)\n.flatMap([n,n.delay(0.75),n.delay(2)])\n.automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(0.5)\n.flatMap([n,n.delay(0.75),n.delay(2)])\n.automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(0.5)\n.map((n) => [n,n.delay(0.75),n.delay(2)])\n.automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(0.5)\n.map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n.automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(0.5)\n.map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n.automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(0.5)\n.map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n.automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \n// export var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n// .duration(0.5)\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \n// export var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n// .duration(0.5)\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(0.5)\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(0.5)\n.map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(2)\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(2).delay(1).set({pitch:[12,13]})\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(4).delay(1).set({pitch:[12,13]})\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(4).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:12,velocity:0.7,duration: 1}).timeFromDurations();\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(4).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:12,velocity:0.7,duration: 1}).loop().timeFromDurations();\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(4).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:12,velocity:0.7,duration: 1}).loop().timeFromDurations();\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(4).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:12,velocity:0.7,duration: 1}).loop().timeFromDurations();\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(4).delay(1)//.set({pitch:})\n\n// export var kick =m.evt({pitch:12,velocity:0.7,duration: 1}).loop().timeFromDurations();\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords85895 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n export var transChords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(4).delay(1)//.set({pitch:})\n\n// export var kick =m.evt({pitch:12,velocity:0.7,duration: 1}).loop().timeFromDurations();\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(4).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:12,velocity:0.7,duration: 1}).loop().timeFromDurations();\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords85895 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords68680 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n export var transChords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(4).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:12,velocity:0.7,duration: 1}).metro(0.25);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin(n.time)+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:14,velocity:[0.7,0.3],duration: 1}).metro(0.25);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n.automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"\nvar chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => notes[(note.pitch-60+(notes.length*1000))%notes.length]*Math.floor((note.pitch-60)/notes.length));\n\n\n\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes());\n\n// var melodyTheme = \nvar melodyTheme = [[0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1]];\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    .set({velocity:0.8})\n    //.pitch(toScale)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:14,velocity:[0.7,0.3],duration: 1}).metro(0.25);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords85895 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords68680 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords17924 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n export var transChords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:32,velocity:[0.7,0.3],duration: 1}).metro(0.25);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:32,velocity:0.1,duration: 1}).metro(0.25);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:32,velocity:0.1,duration: 0.1}).metro(0.25);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:32,velocity:0.5,duration: 0.1}).metro(0.25);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:32,velocity:1,duration: 0.1}).metro(0.25);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:32,velocity:0.8,duration: 0.1}).metro(0.25);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:32,velocity:0.8,duration: 0.1}).metro(0.25).automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);;\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:32,velocity:0.8,duration: 0.1}).metro(0.25).automate(\"pitchBend\",(n) => (n.time%10/10);;\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:32,velocity:0.8,duration: 0.1}).metro(0.5).automate(\"pitchBend\",(n) => (n.time%10/10);;\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:32,velocity:0.8,duration: 0.1}).metro(0.5).automate(\"pitchBend\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(0.5).automate(\"pitchBend\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(0.5).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(0.24).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,57,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,62,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords85895 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords68680 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords17924 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n export var transChords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n export var progression = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords85895 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords68680 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords17924 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords4792 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n export var progression = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n export var transChords = m.data([{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":42,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":51,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":45,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24}]).loopLength(32);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,62,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords85895 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords68680 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords17924 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords4792 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n export var progression = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n export var transChords = m.data([{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":42,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":51,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":45,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24}]).loopLength(32);;\n export var cesaria = m.data([{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28}]).loopLength(32);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords85895 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords68680 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords17924 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords4792 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var progression78526 = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n export var transChords = m.data([{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":42,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":51,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":45,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24}]).loopLength(32);;\n export var cesaria = m.data([{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28}]).loopLength(32);;\n export var progression = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(transChords,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(transChords,1,62,0,0,32);\n    export var transPB3 = pitchBendPlayer(transChords,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = transChords.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:1, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.3,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:2, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.6,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0.7,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:0.2, time:n[0], velocity:0.8})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.6,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0.7,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:0.2, time:n[0], velocity:0.8, color: \"yellow\"})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.6,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0.7,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:0.2, time:n[0], velocity:0.8, color: \"yellow\"})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.6,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0.7,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords85895 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords68680 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords17924 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords4792 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var progression78526 = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n var transChords8043 = m.data([{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":42,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":51,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":45,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24}]).loopLength(32);;\n export var cesaria = m.data([{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28}]).loopLength(32);;\n export var progression = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n export var transChords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords85895 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords68680 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords17924 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords4792 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var progression78526 = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n var transChords8043 = m.data([{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":42,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":51,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":45,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24}]).loopLength(32);;\n export var cesaria = m.data([{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28}]).loopLength(32);;\n var progression76954 = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n export var transChords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n export var progression = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:0.2, time:n[0], velocity:0.8, color: \"yellow\"})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.6,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0.7,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:0.2, time:n[0], velocity:0.8, color: \"yellow\"})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.6,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0.7,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:0.2, time:n[0], velocity:0.8, color: \"yellow\"})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.6,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0.7,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:0.3, time:n[0], velocity:0.8, color: \"yellow\"})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.6,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0.7,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:0.4, time:n[0], velocity:0.8, color: \"yellow\"})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.6,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0.7,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords85895 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords68680 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords17924 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords4792 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var progression78526 = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n var transChords8043 = m.data([{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":42,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":51,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":45,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24}]).loopLength(32);;\n export var cesaria = m.data([{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28}]).loopLength(32);;\n var progression76954 = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n export var transChords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var progression66193 = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n export var progression = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);"
abletonClip	";\n var transparent chords18313 = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparentChords = m.data([{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":42,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":44,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n var transparent chords50208 = m.data([{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":49,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":58,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":37,\"duration\":0.7045779824256897,\"velocity\":0.7086614173228346,\"time\":7.223602771759033},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":51,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":56,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12}]).loopLength(16);;\n export var transparent chords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords98635 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords55081 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords85895 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords68680 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords17924 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var transChords4792 = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var progression78526 = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n var transChords8043 = m.data([{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":42,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":51,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":43,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":47,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":45,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":48,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":52,\"duration\":8,\"velocity\":0.6299212598425197,\"time\":24}]).loopLength(32);;\n export var cesaria = m.data([{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":0},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":4},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":8},{\"pitch\":54,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":63,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":12},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":16},{\"pitch\":55,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":59,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":20},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":24},{\"pitch\":57,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":60,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28},{\"pitch\":64,\"duration\":4,\"velocity\":0.6299212598425197,\"time\":28}]).loopLength(32);;\n var progression76954 = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n export var transChords = m.data([{\"pitch\":49,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":54,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":58,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":51,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":56,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":59,\"duration\":8,\"velocity\":0.7086614173228346,\"time\":8}]).loopLength(16);;\n var progression66193 = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n export var progression = m.data([{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":75,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":70,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":74,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":69,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":72,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":70,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":72,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":71,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31},{\"pitch\":79,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);;\n export var bassprog = m.data([{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":0},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":4},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":8},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":12},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":16},{\"pitch\":79,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":20},{\"pitch\":77,\"duration\":4,\"velocity\":0.7086614173228346,\"time\":24},{\"pitch\":79,\"duration\":3,\"velocity\":0.7086614173228346,\"time\":28},{\"pitch\":77,\"duration\":1,\"velocity\":0.7086614173228346,\"time\":31}]).loopLength(32);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:0.4, time:n[0], velocity:0.8, color: \"yellow\"})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.6,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0.7,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
2	"var chordProg = \"E7 F#7 E7 F#7 Cmaj9 A7 D9 Gmaj9 Cmaj9 F#7 b5 B7\";\nvar chordsBalloon = \"Am7 Cm7 Cm7 Am7 Am7 Cm7 Cm7 Am7\";\n\nvar mapNote = wu.curryable((notes, note) => {\n    // console.log(\"noteIndex\",(note.pitch+(notes.length*1000))%notes.length,notes);\n    return notes[(note.pitch+(notes.length*1000))%notes.length]+12*Math.floor((note.pitch)/notes.length);\n});\n\n\nimport {transChords,progression} from \"abletonClip\";\n\nconsole.log(chordProg);\n\nvar scaleNotes = teoria.scale(\"g\",\"minor\").notes().map((n) => n.key());\n\nvar toScale = mapNote(scaleNotes);\n\nconsole.log(\"scaleNotes\",teoria.scale(\"g\",\"minor\").notes(),scaleNotes);\nconsole.log(\"mappedNote\",toScale({pitch:4}));\n// var melodyTheme = \nvar melodyTheme = [\n                    [0, -4],[3.5, -1],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    [8, -5],[11.5, 2],[4, 0], [5.5, 2], [6,3], [6.5, -2],[7,-1],\n                    ];\n\n\n\nvar duDee = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch-1},{}]);\nvar deDuu = (note) => note.map((n) => [{time: n.time-0.5, pitch:n.pitch+1},{}]);\n\n\nvar baseNote = m.data({velocity:0.8, duration:1});\nconsole.log(\"rying bnotemap\");\n\n// console.log(\"bnotemap\",baseNote.map({pitch: -4, time:0},{pitch:0,time:4},{pitch:6, 0, 3, 7], time:[0,4,6,7] }).take(5).toArray());\n\n// var melodyThemeNew = deDuu(baseNote.map({pitch: [-4, 0, 3, 7], time:[0,4,6,7] }));\n\n// console.log(\"mtheme\",\"\"+melodyThemeNew.take(5).toArray());\n\nexport var melody = m.data(melodyTheme.map(n => ({pitch: n[1], duration:0.3, time:n[0], velocity:0.8, color: \"yellow\"})))\n    // .set({velocity:0.})\n    .pitch(toScale)\n    .pitch(n => n.pitch+24)\n    .loopLength(8); \nconsole.log(\"melodydef\",melody);    \n\nconsole.log(\"melody\",melody.take(5).toArray());\n\nvar defaultNoteCreator = (pitch, chordNo) => ({pitch:pitch, velocity:0.5, duration:2-0.01, time:chordNo*2});\nvar chordProgToM = (text, noteCreator = defaultNoteCreator) => \n    m.data(text.split(\" \").map((textChord,chordNo) => teoria.chord(textChord).notes().map(n => noteCreator(n.key(),chordNo))))\n    .loopLength(text.split(\" \").length*2);\n \n\n\nexport var basicProgression = chordProgToM(chordsBalloon);\n\n\n\nvar pitchBendPlayer = (node, noteNo,basePitch, startAfter, delay, pbendedEvery=16) => {\n    var pbAuto = node.groupByTime().durationsFromTime().set({pitch:basePitch, velocity:0.9}).delay(0.01)\n    .combine(node.groupByTime().eventCount())\n    //  .withNext()\n    //  .map((n) => m.data(n.me).take(1))\n    .automate(\"pitchBend\",(n) => {\n      //   console.log(\"PEEBEE\",n);\n      //  return 0.5;\n      if (!n.evt.other.previous || !n.evt.other.next) {// || n.evt.other.previous.events.length<=noteNo || n.evt.other.next.events.length<=noteNo) {\n        console.warn(\"dont have enough polyphony for this pitchBend automation\");\n        console.log(n);\n        console.log(n.evt.other);\n        return 0.5;\n      }\n      var evtNo1 = Math.floor(n.evt.other.previous.count/16);\n      var evtNo2 = Math.floor(n.evt.other.next.count/16);\n      var prev = n.evt.other.previous.events[noteNo%n.evt.other.previous.events.length];//(noteNo+evtNo1)%n.evt.other.previous.events.length];\n      var next = n.evt.other.next.events[noteNo%n.evt.other.next.events.length];//event(noteNo+evtNo2)%n.evt.other.next.events.length];\n      var nextPitch = next.pitch.valueOf();\n      var prevPitch = prev.pitch.valueOf();\n      var mePitch=n.evt.pitch.valueOf();\n      //console.log(\"pbPlayer\",me,next,n.time, n.duration,mePitch);\n      var pitchNow = (nextPitch-prevPitch)*n.time/n.duration+prevPitch;\n      \n      // console.log(\"pnow\",pitchNow, n.evt.other.previous.count);\n      var meLastDelta = (6*100+prevPitch-mePitch) % 12;\n      if (meLastDelta >6)\n        meLastDelta -=12;\n        // pitchNow=(96+pitchNow)%24-12;\n        // console.log((mePitch%24 - pitchNow)/24);   \n        var meNextDelta = (6*100+nextPitch-mePitch) % 12;\n        if (meNextDelta >6)\n          meNextDelta -=12;\n          //console.log(\"pdelta\",pitchDelta,pitchNow,pitchDelta/12,\"n\",n);\n          \n          var amplitude = 1;\n          var x= n.time/n.duration;\n          var xTransformed = Math.max(0,x-startAfter)*1/(1-startAfter);\n          var easingFunc = easer().using(\"in-expo\");\n          var prop =easingFunc(xTransformed);\n          // prop = 0;\n          var nowDelta=prop*meNextDelta+(1-prop)*meLastDelta;\n          //    console.log(\"newDelta\",nowDelta,\"prevPitch\",prevPitch,\"nextPitch\",nextPitch, \"lastDelta\",meLastDelta,\"nextDelta\",meNextDelta,\"mePitch\",mePitch);\n          //   console.log(\"res\",0.5 + nowDelta/12)\n          return Math.max(0,Math.min(1,0.5 + nowDelta/12));\n        }\n      ).prop(\"pitchBend\", (n) => n.pitchBend );\n      var res = m.evt({pitch:basePitch, velocity:0.9}).metro(t.bars(pbendedEvery)).durationsFromTime()//   \n      .notePlay().merge(pbAuto.delay(delay));\n      return res;\n    };\n    \n    export var transPB1 = pitchBendPlayer(progression,0,50,0.6,0,32);\n    export var transPB2 = pitchBendPlayer(progression,1,62,0,0.7,32);\n    export var transPB3 = pitchBendPlayer(progression,2,60,0.2,0,32);\n// console.log(transChords); \nexport var rhythmicTrans = progression.groupByTime().map((grouped) => grouped.events[0]).pitch((n) => n.time%12<6 ? n.pitch+12:n.pitch+24)\n.duration(3).delay(1)//.set({pitch:})\n\nexport var kick =m.evt({pitch:40,velocity:0.8,duration: 0.1}).metro(2).automate(\"param2\",(n) => n.time%10/10);\n// .map((n) => [n,n.delay(0.75),n.delay(2),n.pitch((n) => n.pitch+12)])\n// .automate(\"pitchBend\",(n) => (Math.sin()*n.time+1)/4+0.25);\n// .map((n) => (n.set({duration:0.1})));\n\n// console.log(basicProgression);"
